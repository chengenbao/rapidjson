// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MasterService.proto

#ifndef PROTOBUF_INCLUDED_MasterService_2eproto
#define PROTOBUF_INCLUDED_MasterService_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_MasterService_2eproto 

namespace protobuf_MasterService_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_MasterService_2eproto
class AuthenticateInfo;
class AuthenticateInfoDefaultTypeInternal;
extern AuthenticateInfoDefaultTypeInternal _AuthenticateInfo_default_instance_;
class CloseRequestC2M;
class CloseRequestC2MDefaultTypeInternal;
extern CloseRequestC2MDefaultTypeInternal _CloseRequestC2M_default_instance_;
class CloseRequestP2M;
class CloseRequestP2MDefaultTypeInternal;
extern CloseRequestP2MDefaultTypeInternal _CloseRequestP2M_default_instance_;
class CloseResponseM2C;
class CloseResponseM2CDefaultTypeInternal;
extern CloseResponseM2CDefaultTypeInternal _CloseResponseM2C_default_instance_;
class CloseResponseM2P;
class CloseResponseM2PDefaultTypeInternal;
extern CloseResponseM2PDefaultTypeInternal _CloseResponseM2P_default_instance_;
class EnableBrokerFunInfo;
class EnableBrokerFunInfoDefaultTypeInternal;
extern EnableBrokerFunInfoDefaultTypeInternal _EnableBrokerFunInfo_default_instance_;
class EventProto;
class EventProtoDefaultTypeInternal;
extern EventProtoDefaultTypeInternal _EventProto_default_instance_;
class HeartRequestC2M;
class HeartRequestC2MDefaultTypeInternal;
extern HeartRequestC2MDefaultTypeInternal _HeartRequestC2M_default_instance_;
class HeartRequestP2M;
class HeartRequestP2MDefaultTypeInternal;
extern HeartRequestP2MDefaultTypeInternal _HeartRequestP2M_default_instance_;
class HeartResponseM2C;
class HeartResponseM2CDefaultTypeInternal;
extern HeartResponseM2CDefaultTypeInternal _HeartResponseM2C_default_instance_;
class HeartResponseM2P;
class HeartResponseM2PDefaultTypeInternal;
extern HeartResponseM2PDefaultTypeInternal _HeartResponseM2P_default_instance_;
class MasterAuthorizedInfo;
class MasterAuthorizedInfoDefaultTypeInternal;
extern MasterAuthorizedInfoDefaultTypeInternal _MasterAuthorizedInfo_default_instance_;
class MasterBrokerAuthorizedInfo;
class MasterBrokerAuthorizedInfoDefaultTypeInternal;
extern MasterBrokerAuthorizedInfoDefaultTypeInternal _MasterBrokerAuthorizedInfo_default_instance_;
class MasterCertificateInfo;
class MasterCertificateInfoDefaultTypeInternal;
extern MasterCertificateInfoDefaultTypeInternal _MasterCertificateInfo_default_instance_;
class RegisterRequestC2M;
class RegisterRequestC2MDefaultTypeInternal;
extern RegisterRequestC2MDefaultTypeInternal _RegisterRequestC2M_default_instance_;
class RegisterRequestP2M;
class RegisterRequestP2MDefaultTypeInternal;
extern RegisterRequestP2MDefaultTypeInternal _RegisterRequestP2M_default_instance_;
class RegisterResponseM2C;
class RegisterResponseM2CDefaultTypeInternal;
extern RegisterResponseM2CDefaultTypeInternal _RegisterResponseM2C_default_instance_;
class RegisterResponseM2P;
class RegisterResponseM2PDefaultTypeInternal;
extern RegisterResponseM2PDefaultTypeInternal _RegisterResponseM2P_default_instance_;
namespace google {
namespace protobuf {
template<> ::AuthenticateInfo* Arena::CreateMaybeMessage<::AuthenticateInfo>(Arena*);
template<> ::CloseRequestC2M* Arena::CreateMaybeMessage<::CloseRequestC2M>(Arena*);
template<> ::CloseRequestP2M* Arena::CreateMaybeMessage<::CloseRequestP2M>(Arena*);
template<> ::CloseResponseM2C* Arena::CreateMaybeMessage<::CloseResponseM2C>(Arena*);
template<> ::CloseResponseM2P* Arena::CreateMaybeMessage<::CloseResponseM2P>(Arena*);
template<> ::EnableBrokerFunInfo* Arena::CreateMaybeMessage<::EnableBrokerFunInfo>(Arena*);
template<> ::EventProto* Arena::CreateMaybeMessage<::EventProto>(Arena*);
template<> ::HeartRequestC2M* Arena::CreateMaybeMessage<::HeartRequestC2M>(Arena*);
template<> ::HeartRequestP2M* Arena::CreateMaybeMessage<::HeartRequestP2M>(Arena*);
template<> ::HeartResponseM2C* Arena::CreateMaybeMessage<::HeartResponseM2C>(Arena*);
template<> ::HeartResponseM2P* Arena::CreateMaybeMessage<::HeartResponseM2P>(Arena*);
template<> ::MasterAuthorizedInfo* Arena::CreateMaybeMessage<::MasterAuthorizedInfo>(Arena*);
template<> ::MasterBrokerAuthorizedInfo* Arena::CreateMaybeMessage<::MasterBrokerAuthorizedInfo>(Arena*);
template<> ::MasterCertificateInfo* Arena::CreateMaybeMessage<::MasterCertificateInfo>(Arena*);
template<> ::RegisterRequestC2M* Arena::CreateMaybeMessage<::RegisterRequestC2M>(Arena*);
template<> ::RegisterRequestP2M* Arena::CreateMaybeMessage<::RegisterRequestP2M>(Arena*);
template<> ::RegisterResponseM2C* Arena::CreateMaybeMessage<::RegisterResponseM2C>(Arena*);
template<> ::RegisterResponseM2P* Arena::CreateMaybeMessage<::RegisterResponseM2P>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class EventProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EventProto) */ {
 public:
  EventProto();
  virtual ~EventProto();

  EventProto(const EventProto& from);

  inline EventProto& operator=(const EventProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventProto(EventProto&& from) noexcept
    : EventProto() {
    *this = ::std::move(from);
  }

  inline EventProto& operator=(EventProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventProto* internal_default_instance() {
    return reinterpret_cast<const EventProto*>(
               &_EventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EventProto* other);
  friend void swap(EventProto& a, EventProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventProto* New() const final {
    return CreateMaybeMessage<EventProto>(NULL);
  }

  EventProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventProto& from);
  void MergeFrom(const EventProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string subscribeInfo = 4;
  int subscribeinfo_size() const;
  void clear_subscribeinfo();
  static const int kSubscribeInfoFieldNumber = 4;
  const ::std::string& subscribeinfo(int index) const;
  ::std::string* mutable_subscribeinfo(int index);
  void set_subscribeinfo(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_subscribeinfo(int index, ::std::string&& value);
  #endif
  void set_subscribeinfo(int index, const char* value);
  void set_subscribeinfo(int index, const char* value, size_t size);
  ::std::string* add_subscribeinfo();
  void add_subscribeinfo(const ::std::string& value);
  #if LANG_CXX11
  void add_subscribeinfo(::std::string&& value);
  #endif
  void add_subscribeinfo(const char* value);
  void add_subscribeinfo(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& subscribeinfo() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subscribeinfo();

  // optional int64 rebalanceId = 1;
  bool has_rebalanceid() const;
  void clear_rebalanceid();
  static const int kRebalanceIdFieldNumber = 1;
  ::google::protobuf::int64 rebalanceid() const;
  void set_rebalanceid(::google::protobuf::int64 value);

  // optional int32 opType = 2;
  bool has_optype() const;
  void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  ::google::protobuf::int32 optype() const;
  void set_optype(::google::protobuf::int32 value);

  // optional int32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EventProto)
 private:
  void set_has_rebalanceid();
  void clear_has_rebalanceid();
  void set_has_optype();
  void clear_has_optype();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subscribeinfo_;
  ::google::protobuf::int64 rebalanceid_;
  ::google::protobuf::int32 optype_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnableBrokerFunInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EnableBrokerFunInfo) */ {
 public:
  EnableBrokerFunInfo();
  virtual ~EnableBrokerFunInfo();

  EnableBrokerFunInfo(const EnableBrokerFunInfo& from);

  inline EnableBrokerFunInfo& operator=(const EnableBrokerFunInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnableBrokerFunInfo(EnableBrokerFunInfo&& from) noexcept
    : EnableBrokerFunInfo() {
    *this = ::std::move(from);
  }

  inline EnableBrokerFunInfo& operator=(EnableBrokerFunInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnableBrokerFunInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnableBrokerFunInfo* internal_default_instance() {
    return reinterpret_cast<const EnableBrokerFunInfo*>(
               &_EnableBrokerFunInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EnableBrokerFunInfo* other);
  friend void swap(EnableBrokerFunInfo& a, EnableBrokerFunInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnableBrokerFunInfo* New() const final {
    return CreateMaybeMessage<EnableBrokerFunInfo>(NULL);
  }

  EnableBrokerFunInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnableBrokerFunInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnableBrokerFunInfo& from);
  void MergeFrom(const EnableBrokerFunInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnableBrokerFunInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool enableConsumeAuthenticate = 1;
  bool has_enableconsumeauthenticate() const;
  void clear_enableconsumeauthenticate();
  static const int kEnableConsumeAuthenticateFieldNumber = 1;
  bool enableconsumeauthenticate() const;
  void set_enableconsumeauthenticate(bool value);

  // required bool enableConsumeAuthorize = 2;
  bool has_enableconsumeauthorize() const;
  void clear_enableconsumeauthorize();
  static const int kEnableConsumeAuthorizeFieldNumber = 2;
  bool enableconsumeauthorize() const;
  void set_enableconsumeauthorize(bool value);

  // required bool enableProduceAuthenticate = 3;
  bool has_enableproduceauthenticate() const;
  void clear_enableproduceauthenticate();
  static const int kEnableProduceAuthenticateFieldNumber = 3;
  bool enableproduceauthenticate() const;
  void set_enableproduceauthenticate(bool value);

  // required bool enableProduceAuthorize = 4;
  bool has_enableproduceauthorize() const;
  void clear_enableproduceauthorize();
  static const int kEnableProduceAuthorizeFieldNumber = 4;
  bool enableproduceauthorize() const;
  void set_enableproduceauthorize(bool value);

  // optional bool enableVisitTokenCheck = 5;
  bool has_enablevisittokencheck() const;
  void clear_enablevisittokencheck();
  static const int kEnableVisitTokenCheckFieldNumber = 5;
  bool enablevisittokencheck() const;
  void set_enablevisittokencheck(bool value);

  // @@protoc_insertion_point(class_scope:EnableBrokerFunInfo)
 private:
  void set_has_enableconsumeauthenticate();
  void clear_has_enableconsumeauthenticate();
  void set_has_enableconsumeauthorize();
  void clear_has_enableconsumeauthorize();
  void set_has_enableproduceauthenticate();
  void clear_has_enableproduceauthenticate();
  void set_has_enableproduceauthorize();
  void clear_has_enableproduceauthorize();
  void set_has_enablevisittokencheck();
  void clear_has_enablevisittokencheck();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool enableconsumeauthenticate_;
  bool enableconsumeauthorize_;
  bool enableproduceauthenticate_;
  bool enableproduceauthorize_;
  bool enablevisittokencheck_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthenticateInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AuthenticateInfo) */ {
 public:
  AuthenticateInfo();
  virtual ~AuthenticateInfo();

  AuthenticateInfo(const AuthenticateInfo& from);

  inline AuthenticateInfo& operator=(const AuthenticateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticateInfo(AuthenticateInfo&& from) noexcept
    : AuthenticateInfo() {
    *this = ::std::move(from);
  }

  inline AuthenticateInfo& operator=(AuthenticateInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticateInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticateInfo* internal_default_instance() {
    return reinterpret_cast<const AuthenticateInfo*>(
               &_AuthenticateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AuthenticateInfo* other);
  friend void swap(AuthenticateInfo& a, AuthenticateInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticateInfo* New() const final {
    return CreateMaybeMessage<AuthenticateInfo>(NULL);
  }

  AuthenticateInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthenticateInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthenticateInfo& from);
  void MergeFrom(const AuthenticateInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticateInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required string othParams = 4;
  bool has_othparams() const;
  void clear_othparams();
  static const int kOthParamsFieldNumber = 4;
  const ::std::string& othparams() const;
  void set_othparams(const ::std::string& value);
  #if LANG_CXX11
  void set_othparams(::std::string&& value);
  #endif
  void set_othparams(const char* value);
  void set_othparams(const char* value, size_t size);
  ::std::string* mutable_othparams();
  ::std::string* release_othparams();
  void set_allocated_othparams(::std::string* othparams);

  // required string signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required int32 nonce = 3;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 3;
  ::google::protobuf::int32 nonce() const;
  void set_nonce(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateInfo)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_nonce();
  void clear_has_nonce();
  void set_has_othparams();
  void clear_has_othparams();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr othparams_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 nonce_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MasterCertificateInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MasterCertificateInfo) */ {
 public:
  MasterCertificateInfo();
  virtual ~MasterCertificateInfo();

  MasterCertificateInfo(const MasterCertificateInfo& from);

  inline MasterCertificateInfo& operator=(const MasterCertificateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterCertificateInfo(MasterCertificateInfo&& from) noexcept
    : MasterCertificateInfo() {
    *this = ::std::move(from);
  }

  inline MasterCertificateInfo& operator=(MasterCertificateInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterCertificateInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterCertificateInfo* internal_default_instance() {
    return reinterpret_cast<const MasterCertificateInfo*>(
               &_MasterCertificateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MasterCertificateInfo* other);
  friend void swap(MasterCertificateInfo& a, MasterCertificateInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterCertificateInfo* New() const final {
    return CreateMaybeMessage<MasterCertificateInfo>(NULL);
  }

  MasterCertificateInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MasterCertificateInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MasterCertificateInfo& from);
  void MergeFrom(const MasterCertificateInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterCertificateInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string authorizedToken = 2;
  bool has_authorizedtoken() const;
  void clear_authorizedtoken();
  static const int kAuthorizedTokenFieldNumber = 2;
  const ::std::string& authorizedtoken() const;
  void set_authorizedtoken(const ::std::string& value);
  #if LANG_CXX11
  void set_authorizedtoken(::std::string&& value);
  #endif
  void set_authorizedtoken(const char* value);
  void set_authorizedtoken(const char* value, size_t size);
  ::std::string* mutable_authorizedtoken();
  ::std::string* release_authorizedtoken();
  void set_allocated_authorizedtoken(::std::string* authorizedtoken);

  // optional .AuthenticateInfo authInfo = 1;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 1;
  private:
  const ::AuthenticateInfo& _internal_authinfo() const;
  public:
  const ::AuthenticateInfo& authinfo() const;
  ::AuthenticateInfo* release_authinfo();
  ::AuthenticateInfo* mutable_authinfo();
  void set_allocated_authinfo(::AuthenticateInfo* authinfo);

  // @@protoc_insertion_point(class_scope:MasterCertificateInfo)
 private:
  void set_has_authinfo();
  void clear_has_authinfo();
  void set_has_authorizedtoken();
  void clear_has_authorizedtoken();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr authorizedtoken_;
  ::AuthenticateInfo* authinfo_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MasterAuthorizedInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MasterAuthorizedInfo) */ {
 public:
  MasterAuthorizedInfo();
  virtual ~MasterAuthorizedInfo();

  MasterAuthorizedInfo(const MasterAuthorizedInfo& from);

  inline MasterAuthorizedInfo& operator=(const MasterAuthorizedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterAuthorizedInfo(MasterAuthorizedInfo&& from) noexcept
    : MasterAuthorizedInfo() {
    *this = ::std::move(from);
  }

  inline MasterAuthorizedInfo& operator=(MasterAuthorizedInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterAuthorizedInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterAuthorizedInfo* internal_default_instance() {
    return reinterpret_cast<const MasterAuthorizedInfo*>(
               &_MasterAuthorizedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MasterAuthorizedInfo* other);
  friend void swap(MasterAuthorizedInfo& a, MasterAuthorizedInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterAuthorizedInfo* New() const final {
    return CreateMaybeMessage<MasterAuthorizedInfo>(NULL);
  }

  MasterAuthorizedInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MasterAuthorizedInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MasterAuthorizedInfo& from);
  void MergeFrom(const MasterAuthorizedInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterAuthorizedInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string authAuthorizedToken = 2;
  bool has_authauthorizedtoken() const;
  void clear_authauthorizedtoken();
  static const int kAuthAuthorizedTokenFieldNumber = 2;
  const ::std::string& authauthorizedtoken() const;
  void set_authauthorizedtoken(const ::std::string& value);
  #if LANG_CXX11
  void set_authauthorizedtoken(::std::string&& value);
  #endif
  void set_authauthorizedtoken(const char* value);
  void set_authauthorizedtoken(const char* value, size_t size);
  ::std::string* mutable_authauthorizedtoken();
  ::std::string* release_authauthorizedtoken();
  void set_allocated_authauthorizedtoken(::std::string* authauthorizedtoken);

  // required int64 visitAuthorizedToken = 1;
  bool has_visitauthorizedtoken() const;
  void clear_visitauthorizedtoken();
  static const int kVisitAuthorizedTokenFieldNumber = 1;
  ::google::protobuf::int64 visitauthorizedtoken() const;
  void set_visitauthorizedtoken(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MasterAuthorizedInfo)
 private:
  void set_has_visitauthorizedtoken();
  void clear_has_visitauthorizedtoken();
  void set_has_authauthorizedtoken();
  void clear_has_authauthorizedtoken();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr authauthorizedtoken_;
  ::google::protobuf::int64 visitauthorizedtoken_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MasterBrokerAuthorizedInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MasterBrokerAuthorizedInfo) */ {
 public:
  MasterBrokerAuthorizedInfo();
  virtual ~MasterBrokerAuthorizedInfo();

  MasterBrokerAuthorizedInfo(const MasterBrokerAuthorizedInfo& from);

  inline MasterBrokerAuthorizedInfo& operator=(const MasterBrokerAuthorizedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterBrokerAuthorizedInfo(MasterBrokerAuthorizedInfo&& from) noexcept
    : MasterBrokerAuthorizedInfo() {
    *this = ::std::move(from);
  }

  inline MasterBrokerAuthorizedInfo& operator=(MasterBrokerAuthorizedInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterBrokerAuthorizedInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterBrokerAuthorizedInfo* internal_default_instance() {
    return reinterpret_cast<const MasterBrokerAuthorizedInfo*>(
               &_MasterBrokerAuthorizedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MasterBrokerAuthorizedInfo* other);
  friend void swap(MasterBrokerAuthorizedInfo& a, MasterBrokerAuthorizedInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterBrokerAuthorizedInfo* New() const final {
    return CreateMaybeMessage<MasterBrokerAuthorizedInfo>(NULL);
  }

  MasterBrokerAuthorizedInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MasterBrokerAuthorizedInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MasterBrokerAuthorizedInfo& from);
  void MergeFrom(const MasterBrokerAuthorizedInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterBrokerAuthorizedInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string visitAuthorizedToken = 1;
  bool has_visitauthorizedtoken() const;
  void clear_visitauthorizedtoken();
  static const int kVisitAuthorizedTokenFieldNumber = 1;
  const ::std::string& visitauthorizedtoken() const;
  void set_visitauthorizedtoken(const ::std::string& value);
  #if LANG_CXX11
  void set_visitauthorizedtoken(::std::string&& value);
  #endif
  void set_visitauthorizedtoken(const char* value);
  void set_visitauthorizedtoken(const char* value, size_t size);
  ::std::string* mutable_visitauthorizedtoken();
  ::std::string* release_visitauthorizedtoken();
  void set_allocated_visitauthorizedtoken(::std::string* visitauthorizedtoken);

  // optional string authAuthorizedToken = 2;
  bool has_authauthorizedtoken() const;
  void clear_authauthorizedtoken();
  static const int kAuthAuthorizedTokenFieldNumber = 2;
  const ::std::string& authauthorizedtoken() const;
  void set_authauthorizedtoken(const ::std::string& value);
  #if LANG_CXX11
  void set_authauthorizedtoken(::std::string&& value);
  #endif
  void set_authauthorizedtoken(const char* value);
  void set_authauthorizedtoken(const char* value, size_t size);
  ::std::string* mutable_authauthorizedtoken();
  ::std::string* release_authauthorizedtoken();
  void set_allocated_authauthorizedtoken(::std::string* authauthorizedtoken);

  // @@protoc_insertion_point(class_scope:MasterBrokerAuthorizedInfo)
 private:
  void set_has_visitauthorizedtoken();
  void clear_has_visitauthorizedtoken();
  void set_has_authauthorizedtoken();
  void clear_has_authauthorizedtoken();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr visitauthorizedtoken_;
  ::google::protobuf::internal::ArenaStringPtr authauthorizedtoken_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequestP2M : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegisterRequestP2M) */ {
 public:
  RegisterRequestP2M();
  virtual ~RegisterRequestP2M();

  RegisterRequestP2M(const RegisterRequestP2M& from);

  inline RegisterRequestP2M& operator=(const RegisterRequestP2M& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequestP2M(RegisterRequestP2M&& from) noexcept
    : RegisterRequestP2M() {
    *this = ::std::move(from);
  }

  inline RegisterRequestP2M& operator=(RegisterRequestP2M&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequestP2M& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequestP2M* internal_default_instance() {
    return reinterpret_cast<const RegisterRequestP2M*>(
               &_RegisterRequestP2M_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RegisterRequestP2M* other);
  friend void swap(RegisterRequestP2M& a, RegisterRequestP2M& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequestP2M* New() const final {
    return CreateMaybeMessage<RegisterRequestP2M>(NULL);
  }

  RegisterRequestP2M* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequestP2M>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequestP2M& from);
  void MergeFrom(const RegisterRequestP2M& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequestP2M* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topicList = 2;
  int topiclist_size() const;
  void clear_topiclist();
  static const int kTopicListFieldNumber = 2;
  const ::std::string& topiclist(int index) const;
  ::std::string* mutable_topiclist(int index);
  void set_topiclist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topiclist(int index, ::std::string&& value);
  #endif
  void set_topiclist(int index, const char* value);
  void set_topiclist(int index, const char* value, size_t size);
  ::std::string* add_topiclist();
  void add_topiclist(const ::std::string& value);
  #if LANG_CXX11
  void add_topiclist(::std::string&& value);
  #endif
  void add_topiclist(const char* value);
  void add_topiclist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topiclist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topiclist();

  // required string clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // required string hostName = 4;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostNameFieldNumber = 4;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string jdkVersion = 6;
  bool has_jdkversion() const;
  void clear_jdkversion();
  static const int kJdkVersionFieldNumber = 6;
  const ::std::string& jdkversion() const;
  void set_jdkversion(const ::std::string& value);
  #if LANG_CXX11
  void set_jdkversion(::std::string&& value);
  #endif
  void set_jdkversion(const char* value);
  void set_jdkversion(const char* value, size_t size);
  ::std::string* mutable_jdkversion();
  ::std::string* release_jdkversion();
  void set_allocated_jdkversion(::std::string* jdkversion);

  // optional .MasterCertificateInfo authInfo = 5;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 5;
  private:
  const ::MasterCertificateInfo& _internal_authinfo() const;
  public:
  const ::MasterCertificateInfo& authinfo() const;
  ::MasterCertificateInfo* release_authinfo();
  ::MasterCertificateInfo* mutable_authinfo();
  void set_allocated_authinfo(::MasterCertificateInfo* authinfo);

  // required int64 brokerCheckSum = 3;
  bool has_brokerchecksum() const;
  void clear_brokerchecksum();
  static const int kBrokerCheckSumFieldNumber = 3;
  ::google::protobuf::int64 brokerchecksum() const;
  void set_brokerchecksum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RegisterRequestP2M)
 private:
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_brokerchecksum();
  void clear_has_brokerchecksum();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_authinfo();
  void clear_has_authinfo();
  void set_has_jdkversion();
  void clear_has_jdkversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topiclist_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr jdkversion_;
  ::MasterCertificateInfo* authinfo_;
  ::google::protobuf::int64 brokerchecksum_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterResponseM2P : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegisterResponseM2P) */ {
 public:
  RegisterResponseM2P();
  virtual ~RegisterResponseM2P();

  RegisterResponseM2P(const RegisterResponseM2P& from);

  inline RegisterResponseM2P& operator=(const RegisterResponseM2P& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponseM2P(RegisterResponseM2P&& from) noexcept
    : RegisterResponseM2P() {
    *this = ::std::move(from);
  }

  inline RegisterResponseM2P& operator=(RegisterResponseM2P&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponseM2P& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponseM2P* internal_default_instance() {
    return reinterpret_cast<const RegisterResponseM2P*>(
               &_RegisterResponseM2P_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RegisterResponseM2P* other);
  friend void swap(RegisterResponseM2P& a, RegisterResponseM2P& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponseM2P* New() const final {
    return CreateMaybeMessage<RegisterResponseM2P>(NULL);
  }

  RegisterResponseM2P* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponseM2P>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponseM2P& from);
  void MergeFrom(const RegisterResponseM2P& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponseM2P* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string brokerInfos = 5;
  int brokerinfos_size() const;
  void clear_brokerinfos();
  static const int kBrokerInfosFieldNumber = 5;
  const ::std::string& brokerinfos(int index) const;
  ::std::string* mutable_brokerinfos(int index);
  void set_brokerinfos(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_brokerinfos(int index, ::std::string&& value);
  #endif
  void set_brokerinfos(int index, const char* value);
  void set_brokerinfos(int index, const char* value, size_t size);
  ::std::string* add_brokerinfos();
  void add_brokerinfos(const ::std::string& value);
  #if LANG_CXX11
  void add_brokerinfos(::std::string&& value);
  #endif
  void add_brokerinfos(const char* value);
  void add_brokerinfos(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& brokerinfos() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_brokerinfos();

  // required string errMsg = 3;
  bool has_errmsg() const;
  void clear_errmsg();
  static const int kErrMsgFieldNumber = 3;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // optional .MasterAuthorizedInfo authorizedInfo = 6;
  bool has_authorizedinfo() const;
  void clear_authorizedinfo();
  static const int kAuthorizedInfoFieldNumber = 6;
  private:
  const ::MasterAuthorizedInfo& _internal_authorizedinfo() const;
  public:
  const ::MasterAuthorizedInfo& authorizedinfo() const;
  ::MasterAuthorizedInfo* release_authorizedinfo();
  ::MasterAuthorizedInfo* mutable_authorizedinfo();
  void set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // required int32 errCode = 2;
  bool has_errcode() const;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // required int64 brokerCheckSum = 4;
  bool has_brokerchecksum() const;
  void clear_brokerchecksum();
  static const int kBrokerCheckSumFieldNumber = 4;
  ::google::protobuf::int64 brokerchecksum() const;
  void set_brokerchecksum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RegisterResponseM2P)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_errcode();
  void clear_has_errcode();
  void set_has_errmsg();
  void clear_has_errmsg();
  void set_has_brokerchecksum();
  void clear_has_brokerchecksum();
  void set_has_authorizedinfo();
  void clear_has_authorizedinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> brokerinfos_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  ::MasterAuthorizedInfo* authorizedinfo_;
  bool success_;
  ::google::protobuf::int32 errcode_;
  ::google::protobuf::int64 brokerchecksum_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartRequestP2M : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HeartRequestP2M) */ {
 public:
  HeartRequestP2M();
  virtual ~HeartRequestP2M();

  HeartRequestP2M(const HeartRequestP2M& from);

  inline HeartRequestP2M& operator=(const HeartRequestP2M& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartRequestP2M(HeartRequestP2M&& from) noexcept
    : HeartRequestP2M() {
    *this = ::std::move(from);
  }

  inline HeartRequestP2M& operator=(HeartRequestP2M&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartRequestP2M& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartRequestP2M* internal_default_instance() {
    return reinterpret_cast<const HeartRequestP2M*>(
               &_HeartRequestP2M_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HeartRequestP2M* other);
  friend void swap(HeartRequestP2M& a, HeartRequestP2M& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartRequestP2M* New() const final {
    return CreateMaybeMessage<HeartRequestP2M>(NULL);
  }

  HeartRequestP2M* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartRequestP2M>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartRequestP2M& from);
  void MergeFrom(const HeartRequestP2M& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartRequestP2M* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topicList = 4;
  int topiclist_size() const;
  void clear_topiclist();
  static const int kTopicListFieldNumber = 4;
  const ::std::string& topiclist(int index) const;
  ::std::string* mutable_topiclist(int index);
  void set_topiclist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topiclist(int index, ::std::string&& value);
  #endif
  void set_topiclist(int index, const char* value);
  void set_topiclist(int index, const char* value, size_t size);
  ::std::string* add_topiclist();
  void add_topiclist(const ::std::string& value);
  #if LANG_CXX11
  void add_topiclist(::std::string&& value);
  #endif
  void add_topiclist(const char* value);
  void add_topiclist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topiclist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topiclist();

  // required string clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // required string hostName = 3;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostNameFieldNumber = 3;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional .MasterCertificateInfo authInfo = 5;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 5;
  private:
  const ::MasterCertificateInfo& _internal_authinfo() const;
  public:
  const ::MasterCertificateInfo& authinfo() const;
  ::MasterCertificateInfo* release_authinfo();
  ::MasterCertificateInfo* mutable_authinfo();
  void set_allocated_authinfo(::MasterCertificateInfo* authinfo);

  // required int64 brokerCheckSum = 2;
  bool has_brokerchecksum() const;
  void clear_brokerchecksum();
  static const int kBrokerCheckSumFieldNumber = 2;
  ::google::protobuf::int64 brokerchecksum() const;
  void set_brokerchecksum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:HeartRequestP2M)
 private:
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_brokerchecksum();
  void clear_has_brokerchecksum();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_authinfo();
  void clear_has_authinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topiclist_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::MasterCertificateInfo* authinfo_;
  ::google::protobuf::int64 brokerchecksum_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartResponseM2P : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HeartResponseM2P) */ {
 public:
  HeartResponseM2P();
  virtual ~HeartResponseM2P();

  HeartResponseM2P(const HeartResponseM2P& from);

  inline HeartResponseM2P& operator=(const HeartResponseM2P& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartResponseM2P(HeartResponseM2P&& from) noexcept
    : HeartResponseM2P() {
    *this = ::std::move(from);
  }

  inline HeartResponseM2P& operator=(HeartResponseM2P&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartResponseM2P& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartResponseM2P* internal_default_instance() {
    return reinterpret_cast<const HeartResponseM2P*>(
               &_HeartResponseM2P_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(HeartResponseM2P* other);
  friend void swap(HeartResponseM2P& a, HeartResponseM2P& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartResponseM2P* New() const final {
    return CreateMaybeMessage<HeartResponseM2P>(NULL);
  }

  HeartResponseM2P* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartResponseM2P>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartResponseM2P& from);
  void MergeFrom(const HeartResponseM2P& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartResponseM2P* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topicInfos = 5;
  int topicinfos_size() const;
  void clear_topicinfos();
  static const int kTopicInfosFieldNumber = 5;
  const ::std::string& topicinfos(int index) const;
  ::std::string* mutable_topicinfos(int index);
  void set_topicinfos(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topicinfos(int index, ::std::string&& value);
  #endif
  void set_topicinfos(int index, const char* value);
  void set_topicinfos(int index, const char* value, size_t size);
  ::std::string* add_topicinfos();
  void add_topicinfos(const ::std::string& value);
  #if LANG_CXX11
  void add_topicinfos(::std::string&& value);
  #endif
  void add_topicinfos(const char* value);
  void add_topicinfos(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topicinfos() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topicinfos();

  // repeated string brokerInfos = 6;
  int brokerinfos_size() const;
  void clear_brokerinfos();
  static const int kBrokerInfosFieldNumber = 6;
  const ::std::string& brokerinfos(int index) const;
  ::std::string* mutable_brokerinfos(int index);
  void set_brokerinfos(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_brokerinfos(int index, ::std::string&& value);
  #endif
  void set_brokerinfos(int index, const char* value);
  void set_brokerinfos(int index, const char* value, size_t size);
  ::std::string* add_brokerinfos();
  void add_brokerinfos(const ::std::string& value);
  #if LANG_CXX11
  void add_brokerinfos(::std::string&& value);
  #endif
  void add_brokerinfos(const char* value);
  void add_brokerinfos(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& brokerinfos() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_brokerinfos();

  // required string errMsg = 3;
  bool has_errmsg() const;
  void clear_errmsg();
  static const int kErrMsgFieldNumber = 3;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // optional .MasterAuthorizedInfo authorizedInfo = 8;
  bool has_authorizedinfo() const;
  void clear_authorizedinfo();
  static const int kAuthorizedInfoFieldNumber = 8;
  private:
  const ::MasterAuthorizedInfo& _internal_authorizedinfo() const;
  public:
  const ::MasterAuthorizedInfo& authorizedinfo() const;
  ::MasterAuthorizedInfo* release_authorizedinfo();
  ::MasterAuthorizedInfo* mutable_authorizedinfo();
  void set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo);

  // required int32 errCode = 2;
  bool has_errcode() const;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional bool requireAuth = 7;
  bool has_requireauth() const;
  void clear_requireauth();
  static const int kRequireAuthFieldNumber = 7;
  bool requireauth() const;
  void set_requireauth(bool value);

  // required int64 brokerCheckSum = 4;
  bool has_brokerchecksum() const;
  void clear_brokerchecksum();
  static const int kBrokerCheckSumFieldNumber = 4;
  ::google::protobuf::int64 brokerchecksum() const;
  void set_brokerchecksum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:HeartResponseM2P)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_errcode();
  void clear_has_errcode();
  void set_has_errmsg();
  void clear_has_errmsg();
  void set_has_brokerchecksum();
  void clear_has_brokerchecksum();
  void set_has_requireauth();
  void clear_has_requireauth();
  void set_has_authorizedinfo();
  void clear_has_authorizedinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topicinfos_;
  ::google::protobuf::RepeatedPtrField< ::std::string> brokerinfos_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  ::MasterAuthorizedInfo* authorizedinfo_;
  ::google::protobuf::int32 errcode_;
  bool success_;
  bool requireauth_;
  ::google::protobuf::int64 brokerchecksum_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseRequestP2M : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CloseRequestP2M) */ {
 public:
  CloseRequestP2M();
  virtual ~CloseRequestP2M();

  CloseRequestP2M(const CloseRequestP2M& from);

  inline CloseRequestP2M& operator=(const CloseRequestP2M& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseRequestP2M(CloseRequestP2M&& from) noexcept
    : CloseRequestP2M() {
    *this = ::std::move(from);
  }

  inline CloseRequestP2M& operator=(CloseRequestP2M&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseRequestP2M& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseRequestP2M* internal_default_instance() {
    return reinterpret_cast<const CloseRequestP2M*>(
               &_CloseRequestP2M_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CloseRequestP2M* other);
  friend void swap(CloseRequestP2M& a, CloseRequestP2M& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseRequestP2M* New() const final {
    return CreateMaybeMessage<CloseRequestP2M>(NULL);
  }

  CloseRequestP2M* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseRequestP2M>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseRequestP2M& from);
  void MergeFrom(const CloseRequestP2M& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseRequestP2M* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // optional .MasterCertificateInfo authInfo = 2;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 2;
  private:
  const ::MasterCertificateInfo& _internal_authinfo() const;
  public:
  const ::MasterCertificateInfo& authinfo() const;
  ::MasterCertificateInfo* release_authinfo();
  ::MasterCertificateInfo* mutable_authinfo();
  void set_allocated_authinfo(::MasterCertificateInfo* authinfo);

  // @@protoc_insertion_point(class_scope:CloseRequestP2M)
 private:
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_authinfo();
  void clear_has_authinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::MasterCertificateInfo* authinfo_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseResponseM2P : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CloseResponseM2P) */ {
 public:
  CloseResponseM2P();
  virtual ~CloseResponseM2P();

  CloseResponseM2P(const CloseResponseM2P& from);

  inline CloseResponseM2P& operator=(const CloseResponseM2P& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseResponseM2P(CloseResponseM2P&& from) noexcept
    : CloseResponseM2P() {
    *this = ::std::move(from);
  }

  inline CloseResponseM2P& operator=(CloseResponseM2P&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseResponseM2P& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseResponseM2P* internal_default_instance() {
    return reinterpret_cast<const CloseResponseM2P*>(
               &_CloseResponseM2P_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CloseResponseM2P* other);
  friend void swap(CloseResponseM2P& a, CloseResponseM2P& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseResponseM2P* New() const final {
    return CreateMaybeMessage<CloseResponseM2P>(NULL);
  }

  CloseResponseM2P* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseResponseM2P>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseResponseM2P& from);
  void MergeFrom(const CloseResponseM2P& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseResponseM2P* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errMsg = 3;
  bool has_errmsg() const;
  void clear_errmsg();
  static const int kErrMsgFieldNumber = 3;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // required int32 errCode = 2;
  bool has_errcode() const;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CloseResponseM2P)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_errcode();
  void clear_has_errcode();
  void set_has_errmsg();
  void clear_has_errmsg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  bool success_;
  ::google::protobuf::int32 errcode_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequestC2M : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegisterRequestC2M) */ {
 public:
  RegisterRequestC2M();
  virtual ~RegisterRequestC2M();

  RegisterRequestC2M(const RegisterRequestC2M& from);

  inline RegisterRequestC2M& operator=(const RegisterRequestC2M& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequestC2M(RegisterRequestC2M&& from) noexcept
    : RegisterRequestC2M() {
    *this = ::std::move(from);
  }

  inline RegisterRequestC2M& operator=(RegisterRequestC2M&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequestC2M& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequestC2M* internal_default_instance() {
    return reinterpret_cast<const RegisterRequestC2M*>(
               &_RegisterRequestC2M_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RegisterRequestC2M* other);
  friend void swap(RegisterRequestC2M& a, RegisterRequestC2M& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequestC2M* New() const final {
    return CreateMaybeMessage<RegisterRequestC2M>(NULL);
  }

  RegisterRequestC2M* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequestC2M>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequestC2M& from);
  void MergeFrom(const RegisterRequestC2M& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequestC2M* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topicList = 4;
  int topiclist_size() const;
  void clear_topiclist();
  static const int kTopicListFieldNumber = 4;
  const ::std::string& topiclist(int index) const;
  ::std::string* mutable_topiclist(int index);
  void set_topiclist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topiclist(int index, ::std::string&& value);
  #endif
  void set_topiclist(int index, const char* value);
  void set_topiclist(int index, const char* value, size_t size);
  ::std::string* add_topiclist();
  void add_topiclist(const ::std::string& value);
  #if LANG_CXX11
  void add_topiclist(::std::string&& value);
  #endif
  void add_topiclist(const char* value);
  void add_topiclist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topiclist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topiclist();

  // repeated string subscribeInfo = 5;
  int subscribeinfo_size() const;
  void clear_subscribeinfo();
  static const int kSubscribeInfoFieldNumber = 5;
  const ::std::string& subscribeinfo(int index) const;
  ::std::string* mutable_subscribeinfo(int index);
  void set_subscribeinfo(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_subscribeinfo(int index, ::std::string&& value);
  #endif
  void set_subscribeinfo(int index, const char* value);
  void set_subscribeinfo(int index, const char* value, size_t size);
  ::std::string* add_subscribeinfo();
  void add_subscribeinfo(const ::std::string& value);
  #if LANG_CXX11
  void add_subscribeinfo(::std::string&& value);
  #endif
  void add_subscribeinfo(const char* value);
  void add_subscribeinfo(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& subscribeinfo() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subscribeinfo();

  // repeated string topicCondition = 6;
  int topiccondition_size() const;
  void clear_topiccondition();
  static const int kTopicConditionFieldNumber = 6;
  const ::std::string& topiccondition(int index) const;
  ::std::string* mutable_topiccondition(int index);
  void set_topiccondition(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topiccondition(int index, ::std::string&& value);
  #endif
  void set_topiccondition(int index, const char* value);
  void set_topiccondition(int index, const char* value, size_t size);
  ::std::string* add_topiccondition();
  void add_topiccondition(const ::std::string& value);
  #if LANG_CXX11
  void add_topiccondition(::std::string&& value);
  #endif
  void add_topiccondition(const char* value);
  void add_topiccondition(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topiccondition() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topiccondition();

  // required string clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // required string groupName = 2;
  bool has_groupname() const;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 2;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // required string hostName = 3;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostNameFieldNumber = 3;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  #if LANG_CXX11
  void set_hostname(::std::string&& value);
  #endif
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional string sessionKey = 9;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 9;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const char* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // optional string requiredPartition = 11;
  bool has_requiredpartition() const;
  void clear_requiredpartition();
  static const int kRequiredPartitionFieldNumber = 11;
  const ::std::string& requiredpartition() const;
  void set_requiredpartition(const ::std::string& value);
  #if LANG_CXX11
  void set_requiredpartition(::std::string&& value);
  #endif
  void set_requiredpartition(const char* value);
  void set_requiredpartition(const char* value, size_t size);
  ::std::string* mutable_requiredpartition();
  ::std::string* release_requiredpartition();
  void set_allocated_requiredpartition(::std::string* requiredpartition);

  // optional string jdkVersion = 19;
  bool has_jdkversion() const;
  void clear_jdkversion();
  static const int kJdkVersionFieldNumber = 19;
  const ::std::string& jdkversion() const;
  void set_jdkversion(const ::std::string& value);
  #if LANG_CXX11
  void set_jdkversion(::std::string&& value);
  #endif
  void set_jdkversion(const char* value);
  void set_jdkversion(const char* value, size_t size);
  ::std::string* mutable_jdkversion();
  ::std::string* release_jdkversion();
  void set_allocated_jdkversion(::std::string* jdkversion);

  // optional .MasterCertificateInfo authInfo = 18;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 18;
  private:
  const ::MasterCertificateInfo& _internal_authinfo() const;
  public:
  const ::MasterCertificateInfo& authinfo() const;
  ::MasterCertificateInfo* release_authinfo();
  ::MasterCertificateInfo* mutable_authinfo();
  void set_allocated_authinfo(::MasterCertificateInfo* authinfo);

  // optional int64 sessionTime = 8;
  bool has_sessiontime() const;
  void clear_sessiontime();
  static const int kSessionTimeFieldNumber = 8;
  ::google::protobuf::int64 sessiontime() const;
  void set_sessiontime(::google::protobuf::int64 value);

  // optional int32 totalCount = 10;
  bool has_totalcount() const;
  void clear_totalcount();
  static const int kTotalCountFieldNumber = 10;
  ::google::protobuf::int32 totalcount() const;
  void set_totalcount(::google::protobuf::int32 value);

  // optional bool requireBound = 7;
  bool has_requirebound() const;
  void clear_requirebound();
  static const int kRequireBoundFieldNumber = 7;
  bool requirebound() const;
  void set_requirebound(bool value);

  // optional bool notAllocated = 12;
  bool has_notallocated() const;
  void clear_notallocated();
  static const int kNotAllocatedFieldNumber = 12;
  bool notallocated() const;
  void set_notallocated(bool value);

  // optional bool selectBig = 13;
  bool has_selectbig() const;
  void clear_selectbig();
  static const int kSelectBigFieldNumber = 13;
  bool selectbig() const;
  void set_selectbig(bool value);

  // optional int64 groupFlowCheckId = 14;
  bool has_groupflowcheckid() const;
  void clear_groupflowcheckid();
  static const int kGroupFlowCheckIdFieldNumber = 14;
  ::google::protobuf::int64 groupflowcheckid() const;
  void set_groupflowcheckid(::google::protobuf::int64 value);

  // optional int64 defFlowCheckId = 15;
  bool has_defflowcheckid() const;
  void clear_defflowcheckid();
  static const int kDefFlowCheckIdFieldNumber = 15;
  ::google::protobuf::int64 defflowcheckid() const;
  void set_defflowcheckid(::google::protobuf::int64 value);

  // optional int64 ssdStoreId = 16;
  bool has_ssdstoreid() const;
  void clear_ssdstoreid();
  static const int kSsdStoreIdFieldNumber = 16;
  ::google::protobuf::int64 ssdstoreid() const;
  void set_ssdstoreid(::google::protobuf::int64 value);

  // optional int32 qryPriorityId = 17;
  bool has_qrypriorityid() const;
  void clear_qrypriorityid();
  static const int kQryPriorityIdFieldNumber = 17;
  ::google::protobuf::int32 qrypriorityid() const;
  void set_qrypriorityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RegisterRequestC2M)
 private:
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_groupname();
  void clear_has_groupname();
  void set_has_hostname();
  void clear_has_hostname();
  void set_has_requirebound();
  void clear_has_requirebound();
  void set_has_sessiontime();
  void clear_has_sessiontime();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_totalcount();
  void clear_has_totalcount();
  void set_has_requiredpartition();
  void clear_has_requiredpartition();
  void set_has_notallocated();
  void clear_has_notallocated();
  void set_has_selectbig();
  void clear_has_selectbig();
  void set_has_groupflowcheckid();
  void clear_has_groupflowcheckid();
  void set_has_defflowcheckid();
  void clear_has_defflowcheckid();
  void set_has_ssdstoreid();
  void clear_has_ssdstoreid();
  void set_has_qrypriorityid();
  void clear_has_qrypriorityid();
  void set_has_authinfo();
  void clear_has_authinfo();
  void set_has_jdkversion();
  void clear_has_jdkversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topiclist_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subscribeinfo_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topiccondition_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  ::google::protobuf::internal::ArenaStringPtr requiredpartition_;
  ::google::protobuf::internal::ArenaStringPtr jdkversion_;
  ::MasterCertificateInfo* authinfo_;
  ::google::protobuf::int64 sessiontime_;
  ::google::protobuf::int32 totalcount_;
  bool requirebound_;
  bool notallocated_;
  bool selectbig_;
  ::google::protobuf::int64 groupflowcheckid_;
  ::google::protobuf::int64 defflowcheckid_;
  ::google::protobuf::int64 ssdstoreid_;
  ::google::protobuf::int32 qrypriorityid_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterResponseM2C : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegisterResponseM2C) */ {
 public:
  RegisterResponseM2C();
  virtual ~RegisterResponseM2C();

  RegisterResponseM2C(const RegisterResponseM2C& from);

  inline RegisterResponseM2C& operator=(const RegisterResponseM2C& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponseM2C(RegisterResponseM2C&& from) noexcept
    : RegisterResponseM2C() {
    *this = ::std::move(from);
  }

  inline RegisterResponseM2C& operator=(RegisterResponseM2C&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponseM2C& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponseM2C* internal_default_instance() {
    return reinterpret_cast<const RegisterResponseM2C*>(
               &_RegisterResponseM2C_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RegisterResponseM2C* other);
  friend void swap(RegisterResponseM2C& a, RegisterResponseM2C& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponseM2C* New() const final {
    return CreateMaybeMessage<RegisterResponseM2C>(NULL);
  }

  RegisterResponseM2C* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponseM2C>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponseM2C& from);
  void MergeFrom(const RegisterResponseM2C& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponseM2C* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topicInfo = 4;
  int topicinfo_size() const;
  void clear_topicinfo();
  static const int kTopicInfoFieldNumber = 4;
  const ::std::string& topicinfo(int index) const;
  ::std::string* mutable_topicinfo(int index);
  void set_topicinfo(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topicinfo(int index, ::std::string&& value);
  #endif
  void set_topicinfo(int index, const char* value);
  void set_topicinfo(int index, const char* value, size_t size);
  ::std::string* add_topicinfo();
  void add_topicinfo(const ::std::string& value);
  #if LANG_CXX11
  void add_topicinfo(::std::string&& value);
  #endif
  void add_topicinfo(const char* value);
  void add_topicinfo(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& topicinfo() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_topicinfo();

  // required string errMsg = 3;
  bool has_errmsg() const;
  void clear_errmsg();
  static const int kErrMsgFieldNumber = 3;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // optional string defFlowControlInfo = 7;
  bool has_defflowcontrolinfo() const;
  void clear_defflowcontrolinfo();
  static const int kDefFlowControlInfoFieldNumber = 7;
  const ::std::string& defflowcontrolinfo() const;
  void set_defflowcontrolinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_defflowcontrolinfo(::std::string&& value);
  #endif
  void set_defflowcontrolinfo(const char* value);
  void set_defflowcontrolinfo(const char* value, size_t size);
  ::std::string* mutable_defflowcontrolinfo();
  ::std::string* release_defflowcontrolinfo();
  void set_allocated_defflowcontrolinfo(::std::string* defflowcontrolinfo);

  // optional string groupFlowControlInfo = 9;
  bool has_groupflowcontrolinfo() const;
  void clear_groupflowcontrolinfo();
  static const int kGroupFlowControlInfoFieldNumber = 9;
  const ::std::string& groupflowcontrolinfo() const;
  void set_groupflowcontrolinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_groupflowcontrolinfo(::std::string&& value);
  #endif
  void set_groupflowcontrolinfo(const char* value);
  void set_groupflowcontrolinfo(const char* value, size_t size);
  ::std::string* mutable_groupflowcontrolinfo();
  ::std::string* release_groupflowcontrolinfo();
  void set_allocated_groupflowcontrolinfo(::std::string* groupflowcontrolinfo);

  // optional .MasterAuthorizedInfo authorizedInfo = 12;
  bool has_authorizedinfo() const;
  void clear_authorizedinfo();
  static const int kAuthorizedInfoFieldNumber = 12;
  private:
  const ::MasterAuthorizedInfo& _internal_authorizedinfo() const;
  public:
  const ::MasterAuthorizedInfo& authorizedinfo() const;
  ::MasterAuthorizedInfo* release_authorizedinfo();
  ::MasterAuthorizedInfo* mutable_authorizedinfo();
  void set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo);

  // required int32 errCode = 2;
  bool has_errcode() const;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional bool notAllocated = 5;
  bool has_notallocated() const;
  void clear_notallocated();
  static const int kNotAllocatedFieldNumber = 5;
  bool notallocated() const;
  void set_notallocated(bool value);

  // optional int64 defFlowCheckId = 6;
  bool has_defflowcheckid() const;
  void clear_defflowcheckid();
  static const int kDefFlowCheckIdFieldNumber = 6;
  ::google::protobuf::int64 defflowcheckid() const;
  void set_defflowcheckid(::google::protobuf::int64 value);

  // optional int64 groupFlowCheckId = 8;
  bool has_groupflowcheckid() const;
  void clear_groupflowcheckid();
  static const int kGroupFlowCheckIdFieldNumber = 8;
  ::google::protobuf::int64 groupflowcheckid() const;
  void set_groupflowcheckid(::google::protobuf::int64 value);

  // optional int64 ssdStoreId = 10;
  bool has_ssdstoreid() const;
  void clear_ssdstoreid();
  static const int kSsdStoreIdFieldNumber = 10;
  ::google::protobuf::int64 ssdstoreid() const;
  void set_ssdstoreid(::google::protobuf::int64 value);

  // optional int32 qryPriorityId = 11;
  bool has_qrypriorityid() const;
  void clear_qrypriorityid();
  static const int kQryPriorityIdFieldNumber = 11;
  ::google::protobuf::int32 qrypriorityid() const;
  void set_qrypriorityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RegisterResponseM2C)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_errcode();
  void clear_has_errcode();
  void set_has_errmsg();
  void clear_has_errmsg();
  void set_has_notallocated();
  void clear_has_notallocated();
  void set_has_defflowcheckid();
  void clear_has_defflowcheckid();
  void set_has_defflowcontrolinfo();
  void clear_has_defflowcontrolinfo();
  void set_has_groupflowcheckid();
  void clear_has_groupflowcheckid();
  void set_has_groupflowcontrolinfo();
  void clear_has_groupflowcontrolinfo();
  void set_has_ssdstoreid();
  void clear_has_ssdstoreid();
  void set_has_qrypriorityid();
  void clear_has_qrypriorityid();
  void set_has_authorizedinfo();
  void clear_has_authorizedinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> topicinfo_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  ::google::protobuf::internal::ArenaStringPtr defflowcontrolinfo_;
  ::google::protobuf::internal::ArenaStringPtr groupflowcontrolinfo_;
  ::MasterAuthorizedInfo* authorizedinfo_;
  ::google::protobuf::int32 errcode_;
  bool success_;
  bool notallocated_;
  ::google::protobuf::int64 defflowcheckid_;
  ::google::protobuf::int64 groupflowcheckid_;
  ::google::protobuf::int64 ssdstoreid_;
  ::google::protobuf::int32 qrypriorityid_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartRequestC2M : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HeartRequestC2M) */ {
 public:
  HeartRequestC2M();
  virtual ~HeartRequestC2M();

  HeartRequestC2M(const HeartRequestC2M& from);

  inline HeartRequestC2M& operator=(const HeartRequestC2M& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartRequestC2M(HeartRequestC2M&& from) noexcept
    : HeartRequestC2M() {
    *this = ::std::move(from);
  }

  inline HeartRequestC2M& operator=(HeartRequestC2M&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartRequestC2M& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartRequestC2M* internal_default_instance() {
    return reinterpret_cast<const HeartRequestC2M*>(
               &_HeartRequestC2M_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(HeartRequestC2M* other);
  friend void swap(HeartRequestC2M& a, HeartRequestC2M& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartRequestC2M* New() const final {
    return CreateMaybeMessage<HeartRequestC2M>(NULL);
  }

  HeartRequestC2M* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartRequestC2M>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartRequestC2M& from);
  void MergeFrom(const HeartRequestC2M& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartRequestC2M* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string subscribeInfo = 3;
  int subscribeinfo_size() const;
  void clear_subscribeinfo();
  static const int kSubscribeInfoFieldNumber = 3;
  const ::std::string& subscribeinfo(int index) const;
  ::std::string* mutable_subscribeinfo(int index);
  void set_subscribeinfo(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_subscribeinfo(int index, ::std::string&& value);
  #endif
  void set_subscribeinfo(int index, const char* value);
  void set_subscribeinfo(int index, const char* value, size_t size);
  ::std::string* add_subscribeinfo();
  void add_subscribeinfo(const ::std::string& value);
  #if LANG_CXX11
  void add_subscribeinfo(::std::string&& value);
  #endif
  void add_subscribeinfo(const char* value);
  void add_subscribeinfo(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& subscribeinfo() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subscribeinfo();

  // required string clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // required string groupName = 2;
  bool has_groupname() const;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 2;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // optional .EventProto event = 5;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 5;
  private:
  const ::EventProto& _internal_event() const;
  public:
  const ::EventProto& event() const;
  ::EventProto* release_event();
  ::EventProto* mutable_event();
  void set_allocated_event(::EventProto* event);

  // optional .MasterCertificateInfo authInfo = 10;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 10;
  private:
  const ::MasterCertificateInfo& _internal_authinfo() const;
  public:
  const ::MasterCertificateInfo& authinfo() const;
  ::MasterCertificateInfo* release_authinfo();
  ::MasterCertificateInfo* mutable_authinfo();
  void set_allocated_authinfo(::MasterCertificateInfo* authinfo);

  // optional int64 defFlowCheckId = 6;
  bool has_defflowcheckid() const;
  void clear_defflowcheckid();
  static const int kDefFlowCheckIdFieldNumber = 6;
  ::google::protobuf::int64 defflowcheckid() const;
  void set_defflowcheckid(::google::protobuf::int64 value);

  // required bool reportSubscribeInfo = 4;
  bool has_reportsubscribeinfo() const;
  void clear_reportsubscribeinfo();
  static const int kReportSubscribeInfoFieldNumber = 4;
  bool reportsubscribeinfo() const;
  void set_reportsubscribeinfo(bool value);

  // optional int32 qryPriorityId = 9;
  bool has_qrypriorityid() const;
  void clear_qrypriorityid();
  static const int kQryPriorityIdFieldNumber = 9;
  ::google::protobuf::int32 qrypriorityid() const;
  void set_qrypriorityid(::google::protobuf::int32 value);

  // optional int64 groupFlowCheckId = 7;
  bool has_groupflowcheckid() const;
  void clear_groupflowcheckid();
  static const int kGroupFlowCheckIdFieldNumber = 7;
  ::google::protobuf::int64 groupflowcheckid() const;
  void set_groupflowcheckid(::google::protobuf::int64 value);

  // optional int64 ssdStoreId = 8;
  bool has_ssdstoreid() const;
  void clear_ssdstoreid();
  static const int kSsdStoreIdFieldNumber = 8;
  ::google::protobuf::int64 ssdstoreid() const;
  void set_ssdstoreid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:HeartRequestC2M)
 private:
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_groupname();
  void clear_has_groupname();
  void set_has_reportsubscribeinfo();
  void clear_has_reportsubscribeinfo();
  void set_has_event();
  void clear_has_event();
  void set_has_defflowcheckid();
  void clear_has_defflowcheckid();
  void set_has_groupflowcheckid();
  void clear_has_groupflowcheckid();
  void set_has_ssdstoreid();
  void clear_has_ssdstoreid();
  void set_has_qrypriorityid();
  void clear_has_qrypriorityid();
  void set_has_authinfo();
  void clear_has_authinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subscribeinfo_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::EventProto* event_;
  ::MasterCertificateInfo* authinfo_;
  ::google::protobuf::int64 defflowcheckid_;
  bool reportsubscribeinfo_;
  ::google::protobuf::int32 qrypriorityid_;
  ::google::protobuf::int64 groupflowcheckid_;
  ::google::protobuf::int64 ssdstoreid_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartResponseM2C : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HeartResponseM2C) */ {
 public:
  HeartResponseM2C();
  virtual ~HeartResponseM2C();

  HeartResponseM2C(const HeartResponseM2C& from);

  inline HeartResponseM2C& operator=(const HeartResponseM2C& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartResponseM2C(HeartResponseM2C&& from) noexcept
    : HeartResponseM2C() {
    *this = ::std::move(from);
  }

  inline HeartResponseM2C& operator=(HeartResponseM2C&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartResponseM2C& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartResponseM2C* internal_default_instance() {
    return reinterpret_cast<const HeartResponseM2C*>(
               &_HeartResponseM2C_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(HeartResponseM2C* other);
  friend void swap(HeartResponseM2C& a, HeartResponseM2C& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartResponseM2C* New() const final {
    return CreateMaybeMessage<HeartResponseM2C>(NULL);
  }

  HeartResponseM2C* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartResponseM2C>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartResponseM2C& from);
  void MergeFrom(const HeartResponseM2C& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartResponseM2C* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errMsg = 3;
  bool has_errmsg() const;
  void clear_errmsg();
  static const int kErrMsgFieldNumber = 3;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // optional string defFlowControlInfo = 7;
  bool has_defflowcontrolinfo() const;
  void clear_defflowcontrolinfo();
  static const int kDefFlowControlInfoFieldNumber = 7;
  const ::std::string& defflowcontrolinfo() const;
  void set_defflowcontrolinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_defflowcontrolinfo(::std::string&& value);
  #endif
  void set_defflowcontrolinfo(const char* value);
  void set_defflowcontrolinfo(const char* value, size_t size);
  ::std::string* mutable_defflowcontrolinfo();
  ::std::string* release_defflowcontrolinfo();
  void set_allocated_defflowcontrolinfo(::std::string* defflowcontrolinfo);

  // optional string groupFlowControlInfo = 9;
  bool has_groupflowcontrolinfo() const;
  void clear_groupflowcontrolinfo();
  static const int kGroupFlowControlInfoFieldNumber = 9;
  const ::std::string& groupflowcontrolinfo() const;
  void set_groupflowcontrolinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_groupflowcontrolinfo(::std::string&& value);
  #endif
  void set_groupflowcontrolinfo(const char* value);
  void set_groupflowcontrolinfo(const char* value, size_t size);
  ::std::string* mutable_groupflowcontrolinfo();
  ::std::string* release_groupflowcontrolinfo();
  void set_allocated_groupflowcontrolinfo(::std::string* groupflowcontrolinfo);

  // optional .EventProto event = 4;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 4;
  private:
  const ::EventProto& _internal_event() const;
  public:
  const ::EventProto& event() const;
  ::EventProto* release_event();
  ::EventProto* mutable_event();
  void set_allocated_event(::EventProto* event);

  // optional .MasterAuthorizedInfo authorizedInfo = 13;
  bool has_authorizedinfo() const;
  void clear_authorizedinfo();
  static const int kAuthorizedInfoFieldNumber = 13;
  private:
  const ::MasterAuthorizedInfo& _internal_authorizedinfo() const;
  public:
  const ::MasterAuthorizedInfo& authorizedinfo() const;
  ::MasterAuthorizedInfo* release_authorizedinfo();
  ::MasterAuthorizedInfo* mutable_authorizedinfo();
  void set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo);

  // required int32 errCode = 2;
  bool has_errcode() const;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional bool notAllocated = 5;
  bool has_notallocated() const;
  void clear_notallocated();
  static const int kNotAllocatedFieldNumber = 5;
  bool notallocated() const;
  void set_notallocated(bool value);

  // optional bool requireAuth = 12;
  bool has_requireauth() const;
  void clear_requireauth();
  static const int kRequireAuthFieldNumber = 12;
  bool requireauth() const;
  void set_requireauth(bool value);

  // optional int64 defFlowCheckId = 6;
  bool has_defflowcheckid() const;
  void clear_defflowcheckid();
  static const int kDefFlowCheckIdFieldNumber = 6;
  ::google::protobuf::int64 defflowcheckid() const;
  void set_defflowcheckid(::google::protobuf::int64 value);

  // optional int64 groupFlowCheckId = 8;
  bool has_groupflowcheckid() const;
  void clear_groupflowcheckid();
  static const int kGroupFlowCheckIdFieldNumber = 8;
  ::google::protobuf::int64 groupflowcheckid() const;
  void set_groupflowcheckid(::google::protobuf::int64 value);

  // optional int64 ssdStoreId = 10;
  bool has_ssdstoreid() const;
  void clear_ssdstoreid();
  static const int kSsdStoreIdFieldNumber = 10;
  ::google::protobuf::int64 ssdstoreid() const;
  void set_ssdstoreid(::google::protobuf::int64 value);

  // optional int32 qryPriorityId = 11;
  bool has_qrypriorityid() const;
  void clear_qrypriorityid();
  static const int kQryPriorityIdFieldNumber = 11;
  ::google::protobuf::int32 qrypriorityid() const;
  void set_qrypriorityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:HeartResponseM2C)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_errcode();
  void clear_has_errcode();
  void set_has_errmsg();
  void clear_has_errmsg();
  void set_has_event();
  void clear_has_event();
  void set_has_notallocated();
  void clear_has_notallocated();
  void set_has_defflowcheckid();
  void clear_has_defflowcheckid();
  void set_has_defflowcontrolinfo();
  void clear_has_defflowcontrolinfo();
  void set_has_groupflowcheckid();
  void clear_has_groupflowcheckid();
  void set_has_groupflowcontrolinfo();
  void clear_has_groupflowcontrolinfo();
  void set_has_ssdstoreid();
  void clear_has_ssdstoreid();
  void set_has_qrypriorityid();
  void clear_has_qrypriorityid();
  void set_has_requireauth();
  void clear_has_requireauth();
  void set_has_authorizedinfo();
  void clear_has_authorizedinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  ::google::protobuf::internal::ArenaStringPtr defflowcontrolinfo_;
  ::google::protobuf::internal::ArenaStringPtr groupflowcontrolinfo_;
  ::EventProto* event_;
  ::MasterAuthorizedInfo* authorizedinfo_;
  ::google::protobuf::int32 errcode_;
  bool success_;
  bool notallocated_;
  bool requireauth_;
  ::google::protobuf::int64 defflowcheckid_;
  ::google::protobuf::int64 groupflowcheckid_;
  ::google::protobuf::int64 ssdstoreid_;
  ::google::protobuf::int32 qrypriorityid_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseRequestC2M : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CloseRequestC2M) */ {
 public:
  CloseRequestC2M();
  virtual ~CloseRequestC2M();

  CloseRequestC2M(const CloseRequestC2M& from);

  inline CloseRequestC2M& operator=(const CloseRequestC2M& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseRequestC2M(CloseRequestC2M&& from) noexcept
    : CloseRequestC2M() {
    *this = ::std::move(from);
  }

  inline CloseRequestC2M& operator=(CloseRequestC2M&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseRequestC2M& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseRequestC2M* internal_default_instance() {
    return reinterpret_cast<const CloseRequestC2M*>(
               &_CloseRequestC2M_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CloseRequestC2M* other);
  friend void swap(CloseRequestC2M& a, CloseRequestC2M& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseRequestC2M* New() const final {
    return CreateMaybeMessage<CloseRequestC2M>(NULL);
  }

  CloseRequestC2M* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseRequestC2M>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseRequestC2M& from);
  void MergeFrom(const CloseRequestC2M& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseRequestC2M* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // required string groupName = 2;
  bool has_groupname() const;
  void clear_groupname();
  static const int kGroupNameFieldNumber = 2;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // optional .MasterCertificateInfo authInfo = 3;
  bool has_authinfo() const;
  void clear_authinfo();
  static const int kAuthInfoFieldNumber = 3;
  private:
  const ::MasterCertificateInfo& _internal_authinfo() const;
  public:
  const ::MasterCertificateInfo& authinfo() const;
  ::MasterCertificateInfo* release_authinfo();
  ::MasterCertificateInfo* mutable_authinfo();
  void set_allocated_authinfo(::MasterCertificateInfo* authinfo);

  // @@protoc_insertion_point(class_scope:CloseRequestC2M)
 private:
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_groupname();
  void clear_has_groupname();
  void set_has_authinfo();
  void clear_has_authinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::MasterCertificateInfo* authinfo_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseResponseM2C : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CloseResponseM2C) */ {
 public:
  CloseResponseM2C();
  virtual ~CloseResponseM2C();

  CloseResponseM2C(const CloseResponseM2C& from);

  inline CloseResponseM2C& operator=(const CloseResponseM2C& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseResponseM2C(CloseResponseM2C&& from) noexcept
    : CloseResponseM2C() {
    *this = ::std::move(from);
  }

  inline CloseResponseM2C& operator=(CloseResponseM2C&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseResponseM2C& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseResponseM2C* internal_default_instance() {
    return reinterpret_cast<const CloseResponseM2C*>(
               &_CloseResponseM2C_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CloseResponseM2C* other);
  friend void swap(CloseResponseM2C& a, CloseResponseM2C& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseResponseM2C* New() const final {
    return CreateMaybeMessage<CloseResponseM2C>(NULL);
  }

  CloseResponseM2C* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseResponseM2C>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseResponseM2C& from);
  void MergeFrom(const CloseResponseM2C& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseResponseM2C* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errMsg = 3;
  bool has_errmsg() const;
  void clear_errmsg();
  static const int kErrMsgFieldNumber = 3;
  const ::std::string& errmsg() const;
  void set_errmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errmsg(::std::string&& value);
  #endif
  void set_errmsg(const char* value);
  void set_errmsg(const char* value, size_t size);
  ::std::string* mutable_errmsg();
  ::std::string* release_errmsg();
  void set_allocated_errmsg(::std::string* errmsg);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // required int32 errCode = 2;
  bool has_errcode() const;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CloseResponseM2C)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_errcode();
  void clear_has_errcode();
  void set_has_errmsg();
  void clear_has_errmsg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errmsg_;
  bool success_;
  ::google::protobuf::int32 errcode_;
  friend struct ::protobuf_MasterService_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EventProto

// optional int64 rebalanceId = 1;
inline bool EventProto::has_rebalanceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventProto::set_has_rebalanceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventProto::clear_has_rebalanceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventProto::clear_rebalanceid() {
  rebalanceid_ = GOOGLE_LONGLONG(0);
  clear_has_rebalanceid();
}
inline ::google::protobuf::int64 EventProto::rebalanceid() const {
  // @@protoc_insertion_point(field_get:EventProto.rebalanceId)
  return rebalanceid_;
}
inline void EventProto::set_rebalanceid(::google::protobuf::int64 value) {
  set_has_rebalanceid();
  rebalanceid_ = value;
  // @@protoc_insertion_point(field_set:EventProto.rebalanceId)
}

// optional int32 opType = 2;
inline bool EventProto::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventProto::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventProto::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventProto::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::google::protobuf::int32 EventProto::optype() const {
  // @@protoc_insertion_point(field_get:EventProto.opType)
  return optype_;
}
inline void EventProto::set_optype(::google::protobuf::int32 value) {
  set_has_optype();
  optype_ = value;
  // @@protoc_insertion_point(field_set:EventProto.opType)
}

// optional int32 status = 3;
inline bool EventProto::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventProto::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 EventProto::status() const {
  // @@protoc_insertion_point(field_get:EventProto.status)
  return status_;
}
inline void EventProto::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:EventProto.status)
}

// repeated string subscribeInfo = 4;
inline int EventProto::subscribeinfo_size() const {
  return subscribeinfo_.size();
}
inline void EventProto::clear_subscribeinfo() {
  subscribeinfo_.Clear();
}
inline const ::std::string& EventProto::subscribeinfo(int index) const {
  // @@protoc_insertion_point(field_get:EventProto.subscribeInfo)
  return subscribeinfo_.Get(index);
}
inline ::std::string* EventProto::mutable_subscribeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:EventProto.subscribeInfo)
  return subscribeinfo_.Mutable(index);
}
inline void EventProto::set_subscribeinfo(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:EventProto.subscribeInfo)
  subscribeinfo_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void EventProto::set_subscribeinfo(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:EventProto.subscribeInfo)
  subscribeinfo_.Mutable(index)->assign(std::move(value));
}
#endif
inline void EventProto::set_subscribeinfo(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subscribeinfo_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:EventProto.subscribeInfo)
}
inline void EventProto::set_subscribeinfo(int index, const char* value, size_t size) {
  subscribeinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:EventProto.subscribeInfo)
}
inline ::std::string* EventProto::add_subscribeinfo() {
  // @@protoc_insertion_point(field_add_mutable:EventProto.subscribeInfo)
  return subscribeinfo_.Add();
}
inline void EventProto::add_subscribeinfo(const ::std::string& value) {
  subscribeinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:EventProto.subscribeInfo)
}
#if LANG_CXX11
inline void EventProto::add_subscribeinfo(::std::string&& value) {
  subscribeinfo_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:EventProto.subscribeInfo)
}
#endif
inline void EventProto::add_subscribeinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subscribeinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:EventProto.subscribeInfo)
}
inline void EventProto::add_subscribeinfo(const char* value, size_t size) {
  subscribeinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:EventProto.subscribeInfo)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EventProto::subscribeinfo() const {
  // @@protoc_insertion_point(field_list:EventProto.subscribeInfo)
  return subscribeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EventProto::mutable_subscribeinfo() {
  // @@protoc_insertion_point(field_mutable_list:EventProto.subscribeInfo)
  return &subscribeinfo_;
}

// -------------------------------------------------------------------

// EnableBrokerFunInfo

// required bool enableConsumeAuthenticate = 1;
inline bool EnableBrokerFunInfo::has_enableconsumeauthenticate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableBrokerFunInfo::set_has_enableconsumeauthenticate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableBrokerFunInfo::clear_has_enableconsumeauthenticate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableBrokerFunInfo::clear_enableconsumeauthenticate() {
  enableconsumeauthenticate_ = false;
  clear_has_enableconsumeauthenticate();
}
inline bool EnableBrokerFunInfo::enableconsumeauthenticate() const {
  // @@protoc_insertion_point(field_get:EnableBrokerFunInfo.enableConsumeAuthenticate)
  return enableconsumeauthenticate_;
}
inline void EnableBrokerFunInfo::set_enableconsumeauthenticate(bool value) {
  set_has_enableconsumeauthenticate();
  enableconsumeauthenticate_ = value;
  // @@protoc_insertion_point(field_set:EnableBrokerFunInfo.enableConsumeAuthenticate)
}

// required bool enableConsumeAuthorize = 2;
inline bool EnableBrokerFunInfo::has_enableconsumeauthorize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableBrokerFunInfo::set_has_enableconsumeauthorize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableBrokerFunInfo::clear_has_enableconsumeauthorize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableBrokerFunInfo::clear_enableconsumeauthorize() {
  enableconsumeauthorize_ = false;
  clear_has_enableconsumeauthorize();
}
inline bool EnableBrokerFunInfo::enableconsumeauthorize() const {
  // @@protoc_insertion_point(field_get:EnableBrokerFunInfo.enableConsumeAuthorize)
  return enableconsumeauthorize_;
}
inline void EnableBrokerFunInfo::set_enableconsumeauthorize(bool value) {
  set_has_enableconsumeauthorize();
  enableconsumeauthorize_ = value;
  // @@protoc_insertion_point(field_set:EnableBrokerFunInfo.enableConsumeAuthorize)
}

// required bool enableProduceAuthenticate = 3;
inline bool EnableBrokerFunInfo::has_enableproduceauthenticate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnableBrokerFunInfo::set_has_enableproduceauthenticate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnableBrokerFunInfo::clear_has_enableproduceauthenticate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnableBrokerFunInfo::clear_enableproduceauthenticate() {
  enableproduceauthenticate_ = false;
  clear_has_enableproduceauthenticate();
}
inline bool EnableBrokerFunInfo::enableproduceauthenticate() const {
  // @@protoc_insertion_point(field_get:EnableBrokerFunInfo.enableProduceAuthenticate)
  return enableproduceauthenticate_;
}
inline void EnableBrokerFunInfo::set_enableproduceauthenticate(bool value) {
  set_has_enableproduceauthenticate();
  enableproduceauthenticate_ = value;
  // @@protoc_insertion_point(field_set:EnableBrokerFunInfo.enableProduceAuthenticate)
}

// required bool enableProduceAuthorize = 4;
inline bool EnableBrokerFunInfo::has_enableproduceauthorize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnableBrokerFunInfo::set_has_enableproduceauthorize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnableBrokerFunInfo::clear_has_enableproduceauthorize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnableBrokerFunInfo::clear_enableproduceauthorize() {
  enableproduceauthorize_ = false;
  clear_has_enableproduceauthorize();
}
inline bool EnableBrokerFunInfo::enableproduceauthorize() const {
  // @@protoc_insertion_point(field_get:EnableBrokerFunInfo.enableProduceAuthorize)
  return enableproduceauthorize_;
}
inline void EnableBrokerFunInfo::set_enableproduceauthorize(bool value) {
  set_has_enableproduceauthorize();
  enableproduceauthorize_ = value;
  // @@protoc_insertion_point(field_set:EnableBrokerFunInfo.enableProduceAuthorize)
}

// optional bool enableVisitTokenCheck = 5;
inline bool EnableBrokerFunInfo::has_enablevisittokencheck() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EnableBrokerFunInfo::set_has_enablevisittokencheck() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EnableBrokerFunInfo::clear_has_enablevisittokencheck() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EnableBrokerFunInfo::clear_enablevisittokencheck() {
  enablevisittokencheck_ = false;
  clear_has_enablevisittokencheck();
}
inline bool EnableBrokerFunInfo::enablevisittokencheck() const {
  // @@protoc_insertion_point(field_get:EnableBrokerFunInfo.enableVisitTokenCheck)
  return enablevisittokencheck_;
}
inline void EnableBrokerFunInfo::set_enablevisittokencheck(bool value) {
  set_has_enablevisittokencheck();
  enablevisittokencheck_ = value;
  // @@protoc_insertion_point(field_set:EnableBrokerFunInfo.enableVisitTokenCheck)
}

// -------------------------------------------------------------------

// AuthenticateInfo

// required string userName = 1;
inline bool AuthenticateInfo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateInfo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& AuthenticateInfo::username() const {
  // @@protoc_insertion_point(field_get:AuthenticateInfo.userName)
  return username_.GetNoArena();
}
inline void AuthenticateInfo::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateInfo.userName)
}
#if LANG_CXX11
inline void AuthenticateInfo::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuthenticateInfo.userName)
}
#endif
inline void AuthenticateInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateInfo.userName)
}
inline void AuthenticateInfo::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateInfo.userName)
}
inline ::std::string* AuthenticateInfo::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:AuthenticateInfo.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateInfo::release_username() {
  // @@protoc_insertion_point(field_release:AuthenticateInfo.userName)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateInfo.userName)
}

// required int64 timestamp = 2;
inline bool AuthenticateInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthenticateInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthenticateInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthenticateInfo::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 AuthenticateInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:AuthenticateInfo.timestamp)
  return timestamp_;
}
inline void AuthenticateInfo::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateInfo.timestamp)
}

// required int32 nonce = 3;
inline bool AuthenticateInfo::has_nonce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuthenticateInfo::set_has_nonce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuthenticateInfo::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuthenticateInfo::clear_nonce() {
  nonce_ = 0;
  clear_has_nonce();
}
inline ::google::protobuf::int32 AuthenticateInfo::nonce() const {
  // @@protoc_insertion_point(field_get:AuthenticateInfo.nonce)
  return nonce_;
}
inline void AuthenticateInfo::set_nonce(::google::protobuf::int32 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:AuthenticateInfo.nonce)
}

// required string othParams = 4;
inline bool AuthenticateInfo::has_othparams() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateInfo::set_has_othparams() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateInfo::clear_has_othparams() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateInfo::clear_othparams() {
  othparams_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_othparams();
}
inline const ::std::string& AuthenticateInfo::othparams() const {
  // @@protoc_insertion_point(field_get:AuthenticateInfo.othParams)
  return othparams_.GetNoArena();
}
inline void AuthenticateInfo::set_othparams(const ::std::string& value) {
  set_has_othparams();
  othparams_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateInfo.othParams)
}
#if LANG_CXX11
inline void AuthenticateInfo::set_othparams(::std::string&& value) {
  set_has_othparams();
  othparams_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuthenticateInfo.othParams)
}
#endif
inline void AuthenticateInfo::set_othparams(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_othparams();
  othparams_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateInfo.othParams)
}
inline void AuthenticateInfo::set_othparams(const char* value, size_t size) {
  set_has_othparams();
  othparams_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateInfo.othParams)
}
inline ::std::string* AuthenticateInfo::mutable_othparams() {
  set_has_othparams();
  // @@protoc_insertion_point(field_mutable:AuthenticateInfo.othParams)
  return othparams_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateInfo::release_othparams() {
  // @@protoc_insertion_point(field_release:AuthenticateInfo.othParams)
  if (!has_othparams()) {
    return NULL;
  }
  clear_has_othparams();
  return othparams_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateInfo::set_allocated_othparams(::std::string* othparams) {
  if (othparams != NULL) {
    set_has_othparams();
  } else {
    clear_has_othparams();
  }
  othparams_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), othparams);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateInfo.othParams)
}

// required string signature = 5;
inline bool AuthenticateInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateInfo::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& AuthenticateInfo::signature() const {
  // @@protoc_insertion_point(field_get:AuthenticateInfo.signature)
  return signature_.GetNoArena();
}
inline void AuthenticateInfo::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuthenticateInfo.signature)
}
#if LANG_CXX11
inline void AuthenticateInfo::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuthenticateInfo.signature)
}
#endif
inline void AuthenticateInfo::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuthenticateInfo.signature)
}
inline void AuthenticateInfo::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuthenticateInfo.signature)
}
inline ::std::string* AuthenticateInfo::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:AuthenticateInfo.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticateInfo::release_signature() {
  // @@protoc_insertion_point(field_release:AuthenticateInfo.signature)
  if (!has_signature()) {
    return NULL;
  }
  clear_has_signature();
  return signature_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticateInfo::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:AuthenticateInfo.signature)
}

// -------------------------------------------------------------------

// MasterCertificateInfo

// optional .AuthenticateInfo authInfo = 1;
inline bool MasterCertificateInfo::has_authinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterCertificateInfo::set_has_authinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterCertificateInfo::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterCertificateInfo::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::AuthenticateInfo& MasterCertificateInfo::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::AuthenticateInfo& MasterCertificateInfo::authinfo() const {
  const ::AuthenticateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:MasterCertificateInfo.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::AuthenticateInfo*>(
      &::_AuthenticateInfo_default_instance_);
}
inline ::AuthenticateInfo* MasterCertificateInfo::release_authinfo() {
  // @@protoc_insertion_point(field_release:MasterCertificateInfo.authInfo)
  clear_has_authinfo();
  ::AuthenticateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::AuthenticateInfo* MasterCertificateInfo::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::AuthenticateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MasterCertificateInfo.authInfo)
  return authinfo_;
}
inline void MasterCertificateInfo::set_allocated_authinfo(::AuthenticateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:MasterCertificateInfo.authInfo)
}

// optional string authorizedToken = 2;
inline bool MasterCertificateInfo::has_authorizedtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterCertificateInfo::set_has_authorizedtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterCertificateInfo::clear_has_authorizedtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterCertificateInfo::clear_authorizedtoken() {
  authorizedtoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authorizedtoken();
}
inline const ::std::string& MasterCertificateInfo::authorizedtoken() const {
  // @@protoc_insertion_point(field_get:MasterCertificateInfo.authorizedToken)
  return authorizedtoken_.GetNoArena();
}
inline void MasterCertificateInfo::set_authorizedtoken(const ::std::string& value) {
  set_has_authorizedtoken();
  authorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MasterCertificateInfo.authorizedToken)
}
#if LANG_CXX11
inline void MasterCertificateInfo::set_authorizedtoken(::std::string&& value) {
  set_has_authorizedtoken();
  authorizedtoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MasterCertificateInfo.authorizedToken)
}
#endif
inline void MasterCertificateInfo::set_authorizedtoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authorizedtoken();
  authorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MasterCertificateInfo.authorizedToken)
}
inline void MasterCertificateInfo::set_authorizedtoken(const char* value, size_t size) {
  set_has_authorizedtoken();
  authorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MasterCertificateInfo.authorizedToken)
}
inline ::std::string* MasterCertificateInfo::mutable_authorizedtoken() {
  set_has_authorizedtoken();
  // @@protoc_insertion_point(field_mutable:MasterCertificateInfo.authorizedToken)
  return authorizedtoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MasterCertificateInfo::release_authorizedtoken() {
  // @@protoc_insertion_point(field_release:MasterCertificateInfo.authorizedToken)
  if (!has_authorizedtoken()) {
    return NULL;
  }
  clear_has_authorizedtoken();
  return authorizedtoken_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MasterCertificateInfo::set_allocated_authorizedtoken(::std::string* authorizedtoken) {
  if (authorizedtoken != NULL) {
    set_has_authorizedtoken();
  } else {
    clear_has_authorizedtoken();
  }
  authorizedtoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authorizedtoken);
  // @@protoc_insertion_point(field_set_allocated:MasterCertificateInfo.authorizedToken)
}

// -------------------------------------------------------------------

// MasterAuthorizedInfo

// required int64 visitAuthorizedToken = 1;
inline bool MasterAuthorizedInfo::has_visitauthorizedtoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterAuthorizedInfo::set_has_visitauthorizedtoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterAuthorizedInfo::clear_has_visitauthorizedtoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterAuthorizedInfo::clear_visitauthorizedtoken() {
  visitauthorizedtoken_ = GOOGLE_LONGLONG(0);
  clear_has_visitauthorizedtoken();
}
inline ::google::protobuf::int64 MasterAuthorizedInfo::visitauthorizedtoken() const {
  // @@protoc_insertion_point(field_get:MasterAuthorizedInfo.visitAuthorizedToken)
  return visitauthorizedtoken_;
}
inline void MasterAuthorizedInfo::set_visitauthorizedtoken(::google::protobuf::int64 value) {
  set_has_visitauthorizedtoken();
  visitauthorizedtoken_ = value;
  // @@protoc_insertion_point(field_set:MasterAuthorizedInfo.visitAuthorizedToken)
}

// optional string authAuthorizedToken = 2;
inline bool MasterAuthorizedInfo::has_authauthorizedtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterAuthorizedInfo::set_has_authauthorizedtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterAuthorizedInfo::clear_has_authauthorizedtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterAuthorizedInfo::clear_authauthorizedtoken() {
  authauthorizedtoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authauthorizedtoken();
}
inline const ::std::string& MasterAuthorizedInfo::authauthorizedtoken() const {
  // @@protoc_insertion_point(field_get:MasterAuthorizedInfo.authAuthorizedToken)
  return authauthorizedtoken_.GetNoArena();
}
inline void MasterAuthorizedInfo::set_authauthorizedtoken(const ::std::string& value) {
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MasterAuthorizedInfo.authAuthorizedToken)
}
#if LANG_CXX11
inline void MasterAuthorizedInfo::set_authauthorizedtoken(::std::string&& value) {
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MasterAuthorizedInfo.authAuthorizedToken)
}
#endif
inline void MasterAuthorizedInfo::set_authauthorizedtoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MasterAuthorizedInfo.authAuthorizedToken)
}
inline void MasterAuthorizedInfo::set_authauthorizedtoken(const char* value, size_t size) {
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MasterAuthorizedInfo.authAuthorizedToken)
}
inline ::std::string* MasterAuthorizedInfo::mutable_authauthorizedtoken() {
  set_has_authauthorizedtoken();
  // @@protoc_insertion_point(field_mutable:MasterAuthorizedInfo.authAuthorizedToken)
  return authauthorizedtoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MasterAuthorizedInfo::release_authauthorizedtoken() {
  // @@protoc_insertion_point(field_release:MasterAuthorizedInfo.authAuthorizedToken)
  if (!has_authauthorizedtoken()) {
    return NULL;
  }
  clear_has_authauthorizedtoken();
  return authauthorizedtoken_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MasterAuthorizedInfo::set_allocated_authauthorizedtoken(::std::string* authauthorizedtoken) {
  if (authauthorizedtoken != NULL) {
    set_has_authauthorizedtoken();
  } else {
    clear_has_authauthorizedtoken();
  }
  authauthorizedtoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authauthorizedtoken);
  // @@protoc_insertion_point(field_set_allocated:MasterAuthorizedInfo.authAuthorizedToken)
}

// -------------------------------------------------------------------

// MasterBrokerAuthorizedInfo

// required string visitAuthorizedToken = 1;
inline bool MasterBrokerAuthorizedInfo::has_visitauthorizedtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterBrokerAuthorizedInfo::set_has_visitauthorizedtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterBrokerAuthorizedInfo::clear_has_visitauthorizedtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterBrokerAuthorizedInfo::clear_visitauthorizedtoken() {
  visitauthorizedtoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_visitauthorizedtoken();
}
inline const ::std::string& MasterBrokerAuthorizedInfo::visitauthorizedtoken() const {
  // @@protoc_insertion_point(field_get:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
  return visitauthorizedtoken_.GetNoArena();
}
inline void MasterBrokerAuthorizedInfo::set_visitauthorizedtoken(const ::std::string& value) {
  set_has_visitauthorizedtoken();
  visitauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
}
#if LANG_CXX11
inline void MasterBrokerAuthorizedInfo::set_visitauthorizedtoken(::std::string&& value) {
  set_has_visitauthorizedtoken();
  visitauthorizedtoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
}
#endif
inline void MasterBrokerAuthorizedInfo::set_visitauthorizedtoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_visitauthorizedtoken();
  visitauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
}
inline void MasterBrokerAuthorizedInfo::set_visitauthorizedtoken(const char* value, size_t size) {
  set_has_visitauthorizedtoken();
  visitauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
}
inline ::std::string* MasterBrokerAuthorizedInfo::mutable_visitauthorizedtoken() {
  set_has_visitauthorizedtoken();
  // @@protoc_insertion_point(field_mutable:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
  return visitauthorizedtoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MasterBrokerAuthorizedInfo::release_visitauthorizedtoken() {
  // @@protoc_insertion_point(field_release:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
  if (!has_visitauthorizedtoken()) {
    return NULL;
  }
  clear_has_visitauthorizedtoken();
  return visitauthorizedtoken_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MasterBrokerAuthorizedInfo::set_allocated_visitauthorizedtoken(::std::string* visitauthorizedtoken) {
  if (visitauthorizedtoken != NULL) {
    set_has_visitauthorizedtoken();
  } else {
    clear_has_visitauthorizedtoken();
  }
  visitauthorizedtoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), visitauthorizedtoken);
  // @@protoc_insertion_point(field_set_allocated:MasterBrokerAuthorizedInfo.visitAuthorizedToken)
}

// optional string authAuthorizedToken = 2;
inline bool MasterBrokerAuthorizedInfo::has_authauthorizedtoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterBrokerAuthorizedInfo::set_has_authauthorizedtoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterBrokerAuthorizedInfo::clear_has_authauthorizedtoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterBrokerAuthorizedInfo::clear_authauthorizedtoken() {
  authauthorizedtoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authauthorizedtoken();
}
inline const ::std::string& MasterBrokerAuthorizedInfo::authauthorizedtoken() const {
  // @@protoc_insertion_point(field_get:MasterBrokerAuthorizedInfo.authAuthorizedToken)
  return authauthorizedtoken_.GetNoArena();
}
inline void MasterBrokerAuthorizedInfo::set_authauthorizedtoken(const ::std::string& value) {
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MasterBrokerAuthorizedInfo.authAuthorizedToken)
}
#if LANG_CXX11
inline void MasterBrokerAuthorizedInfo::set_authauthorizedtoken(::std::string&& value) {
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MasterBrokerAuthorizedInfo.authAuthorizedToken)
}
#endif
inline void MasterBrokerAuthorizedInfo::set_authauthorizedtoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MasterBrokerAuthorizedInfo.authAuthorizedToken)
}
inline void MasterBrokerAuthorizedInfo::set_authauthorizedtoken(const char* value, size_t size) {
  set_has_authauthorizedtoken();
  authauthorizedtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MasterBrokerAuthorizedInfo.authAuthorizedToken)
}
inline ::std::string* MasterBrokerAuthorizedInfo::mutable_authauthorizedtoken() {
  set_has_authauthorizedtoken();
  // @@protoc_insertion_point(field_mutable:MasterBrokerAuthorizedInfo.authAuthorizedToken)
  return authauthorizedtoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MasterBrokerAuthorizedInfo::release_authauthorizedtoken() {
  // @@protoc_insertion_point(field_release:MasterBrokerAuthorizedInfo.authAuthorizedToken)
  if (!has_authauthorizedtoken()) {
    return NULL;
  }
  clear_has_authauthorizedtoken();
  return authauthorizedtoken_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MasterBrokerAuthorizedInfo::set_allocated_authauthorizedtoken(::std::string* authauthorizedtoken) {
  if (authauthorizedtoken != NULL) {
    set_has_authauthorizedtoken();
  } else {
    clear_has_authauthorizedtoken();
  }
  authauthorizedtoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authauthorizedtoken);
  // @@protoc_insertion_point(field_set_allocated:MasterBrokerAuthorizedInfo.authAuthorizedToken)
}

// -------------------------------------------------------------------

// RegisterRequestP2M

// required string clientId = 1;
inline bool RegisterRequestP2M::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequestP2M::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequestP2M::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequestP2M::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& RegisterRequestP2M::clientid() const {
  // @@protoc_insertion_point(field_get:RegisterRequestP2M.clientId)
  return clientid_.GetNoArena();
}
inline void RegisterRequestP2M::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestP2M.clientId)
}
#if LANG_CXX11
inline void RegisterRequestP2M::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestP2M.clientId)
}
#endif
inline void RegisterRequestP2M::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestP2M.clientId)
}
inline void RegisterRequestP2M::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestP2M.clientId)
}
inline ::std::string* RegisterRequestP2M::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:RegisterRequestP2M.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestP2M::release_clientid() {
  // @@protoc_insertion_point(field_release:RegisterRequestP2M.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestP2M::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestP2M.clientId)
}

// repeated string topicList = 2;
inline int RegisterRequestP2M::topiclist_size() const {
  return topiclist_.size();
}
inline void RegisterRequestP2M::clear_topiclist() {
  topiclist_.Clear();
}
inline const ::std::string& RegisterRequestP2M::topiclist(int index) const {
  // @@protoc_insertion_point(field_get:RegisterRequestP2M.topicList)
  return topiclist_.Get(index);
}
inline ::std::string* RegisterRequestP2M::mutable_topiclist(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterRequestP2M.topicList)
  return topiclist_.Mutable(index);
}
inline void RegisterRequestP2M::set_topiclist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestP2M.topicList)
  topiclist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterRequestP2M::set_topiclist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestP2M.topicList)
  topiclist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterRequestP2M::set_topiclist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiclist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequestP2M.topicList)
}
inline void RegisterRequestP2M::set_topiclist(int index, const char* value, size_t size) {
  topiclist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestP2M.topicList)
}
inline ::std::string* RegisterRequestP2M::add_topiclist() {
  // @@protoc_insertion_point(field_add_mutable:RegisterRequestP2M.topicList)
  return topiclist_.Add();
}
inline void RegisterRequestP2M::add_topiclist(const ::std::string& value) {
  topiclist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RegisterRequestP2M.topicList)
}
#if LANG_CXX11
inline void RegisterRequestP2M::add_topiclist(::std::string&& value) {
  topiclist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RegisterRequestP2M.topicList)
}
#endif
inline void RegisterRequestP2M::add_topiclist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiclist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RegisterRequestP2M.topicList)
}
inline void RegisterRequestP2M::add_topiclist(const char* value, size_t size) {
  topiclist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RegisterRequestP2M.topicList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterRequestP2M::topiclist() const {
  // @@protoc_insertion_point(field_list:RegisterRequestP2M.topicList)
  return topiclist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterRequestP2M::mutable_topiclist() {
  // @@protoc_insertion_point(field_mutable_list:RegisterRequestP2M.topicList)
  return &topiclist_;
}

// required int64 brokerCheckSum = 3;
inline bool RegisterRequestP2M::has_brokerchecksum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRequestP2M::set_has_brokerchecksum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRequestP2M::clear_has_brokerchecksum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRequestP2M::clear_brokerchecksum() {
  brokerchecksum_ = GOOGLE_LONGLONG(0);
  clear_has_brokerchecksum();
}
inline ::google::protobuf::int64 RegisterRequestP2M::brokerchecksum() const {
  // @@protoc_insertion_point(field_get:RegisterRequestP2M.brokerCheckSum)
  return brokerchecksum_;
}
inline void RegisterRequestP2M::set_brokerchecksum(::google::protobuf::int64 value) {
  set_has_brokerchecksum();
  brokerchecksum_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestP2M.brokerCheckSum)
}

// required string hostName = 4;
inline bool RegisterRequestP2M::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequestP2M::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequestP2M::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequestP2M::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& RegisterRequestP2M::hostname() const {
  // @@protoc_insertion_point(field_get:RegisterRequestP2M.hostName)
  return hostname_.GetNoArena();
}
inline void RegisterRequestP2M::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestP2M.hostName)
}
#if LANG_CXX11
inline void RegisterRequestP2M::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestP2M.hostName)
}
#endif
inline void RegisterRequestP2M::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestP2M.hostName)
}
inline void RegisterRequestP2M::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestP2M.hostName)
}
inline ::std::string* RegisterRequestP2M::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:RegisterRequestP2M.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestP2M::release_hostname() {
  // @@protoc_insertion_point(field_release:RegisterRequestP2M.hostName)
  if (!has_hostname()) {
    return NULL;
  }
  clear_has_hostname();
  return hostname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestP2M::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestP2M.hostName)
}

// optional .MasterCertificateInfo authInfo = 5;
inline bool RegisterRequestP2M::has_authinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequestP2M::set_has_authinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRequestP2M::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRequestP2M::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::MasterCertificateInfo& RegisterRequestP2M::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::MasterCertificateInfo& RegisterRequestP2M::authinfo() const {
  const ::MasterCertificateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:RegisterRequestP2M.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterCertificateInfo*>(
      &::_MasterCertificateInfo_default_instance_);
}
inline ::MasterCertificateInfo* RegisterRequestP2M::release_authinfo() {
  // @@protoc_insertion_point(field_release:RegisterRequestP2M.authInfo)
  clear_has_authinfo();
  ::MasterCertificateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::MasterCertificateInfo* RegisterRequestP2M::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterCertificateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRequestP2M.authInfo)
  return authinfo_;
}
inline void RegisterRequestP2M::set_allocated_authinfo(::MasterCertificateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestP2M.authInfo)
}

// optional string jdkVersion = 6;
inline bool RegisterRequestP2M::has_jdkversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequestP2M::set_has_jdkversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequestP2M::clear_has_jdkversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequestP2M::clear_jdkversion() {
  jdkversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jdkversion();
}
inline const ::std::string& RegisterRequestP2M::jdkversion() const {
  // @@protoc_insertion_point(field_get:RegisterRequestP2M.jdkVersion)
  return jdkversion_.GetNoArena();
}
inline void RegisterRequestP2M::set_jdkversion(const ::std::string& value) {
  set_has_jdkversion();
  jdkversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestP2M.jdkVersion)
}
#if LANG_CXX11
inline void RegisterRequestP2M::set_jdkversion(::std::string&& value) {
  set_has_jdkversion();
  jdkversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestP2M.jdkVersion)
}
#endif
inline void RegisterRequestP2M::set_jdkversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jdkversion();
  jdkversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestP2M.jdkVersion)
}
inline void RegisterRequestP2M::set_jdkversion(const char* value, size_t size) {
  set_has_jdkversion();
  jdkversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestP2M.jdkVersion)
}
inline ::std::string* RegisterRequestP2M::mutable_jdkversion() {
  set_has_jdkversion();
  // @@protoc_insertion_point(field_mutable:RegisterRequestP2M.jdkVersion)
  return jdkversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestP2M::release_jdkversion() {
  // @@protoc_insertion_point(field_release:RegisterRequestP2M.jdkVersion)
  if (!has_jdkversion()) {
    return NULL;
  }
  clear_has_jdkversion();
  return jdkversion_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestP2M::set_allocated_jdkversion(::std::string* jdkversion) {
  if (jdkversion != NULL) {
    set_has_jdkversion();
  } else {
    clear_has_jdkversion();
  }
  jdkversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jdkversion);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestP2M.jdkVersion)
}

// -------------------------------------------------------------------

// RegisterResponseM2P

// required bool success = 1;
inline bool RegisterResponseM2P::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterResponseM2P::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterResponseM2P::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterResponseM2P::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool RegisterResponseM2P::success() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2P.success)
  return success_;
}
inline void RegisterResponseM2P::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2P.success)
}

// required int32 errCode = 2;
inline bool RegisterResponseM2P::has_errcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterResponseM2P::set_has_errcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterResponseM2P::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterResponseM2P::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 RegisterResponseM2P::errcode() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2P.errCode)
  return errcode_;
}
inline void RegisterResponseM2P::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2P.errCode)
}

// required string errMsg = 3;
inline bool RegisterResponseM2P::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponseM2P::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponseM2P::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponseM2P::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errmsg();
}
inline const ::std::string& RegisterResponseM2P::errmsg() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2P.errMsg)
  return errmsg_.GetNoArena();
}
inline void RegisterResponseM2P::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterResponseM2P.errMsg)
}
#if LANG_CXX11
inline void RegisterResponseM2P::set_errmsg(::std::string&& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterResponseM2P.errMsg)
}
#endif
inline void RegisterResponseM2P::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterResponseM2P.errMsg)
}
inline void RegisterResponseM2P::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterResponseM2P.errMsg)
}
inline ::std::string* RegisterResponseM2P::mutable_errmsg() {
  set_has_errmsg();
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2P.errMsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponseM2P::release_errmsg() {
  // @@protoc_insertion_point(field_release:RegisterResponseM2P.errMsg)
  if (!has_errmsg()) {
    return NULL;
  }
  clear_has_errmsg();
  return errmsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponseM2P::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:RegisterResponseM2P.errMsg)
}

// required int64 brokerCheckSum = 4;
inline bool RegisterResponseM2P::has_brokerchecksum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterResponseM2P::set_has_brokerchecksum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterResponseM2P::clear_has_brokerchecksum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterResponseM2P::clear_brokerchecksum() {
  brokerchecksum_ = GOOGLE_LONGLONG(0);
  clear_has_brokerchecksum();
}
inline ::google::protobuf::int64 RegisterResponseM2P::brokerchecksum() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2P.brokerCheckSum)
  return brokerchecksum_;
}
inline void RegisterResponseM2P::set_brokerchecksum(::google::protobuf::int64 value) {
  set_has_brokerchecksum();
  brokerchecksum_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2P.brokerCheckSum)
}

// repeated string brokerInfos = 5;
inline int RegisterResponseM2P::brokerinfos_size() const {
  return brokerinfos_.size();
}
inline void RegisterResponseM2P::clear_brokerinfos() {
  brokerinfos_.Clear();
}
inline const ::std::string& RegisterResponseM2P::brokerinfos(int index) const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2P.brokerInfos)
  return brokerinfos_.Get(index);
}
inline ::std::string* RegisterResponseM2P::mutable_brokerinfos(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2P.brokerInfos)
  return brokerinfos_.Mutable(index);
}
inline void RegisterResponseM2P::set_brokerinfos(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RegisterResponseM2P.brokerInfos)
  brokerinfos_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterResponseM2P::set_brokerinfos(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RegisterResponseM2P.brokerInfos)
  brokerinfos_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterResponseM2P::set_brokerinfos(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  brokerinfos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterResponseM2P.brokerInfos)
}
inline void RegisterResponseM2P::set_brokerinfos(int index, const char* value, size_t size) {
  brokerinfos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterResponseM2P.brokerInfos)
}
inline ::std::string* RegisterResponseM2P::add_brokerinfos() {
  // @@protoc_insertion_point(field_add_mutable:RegisterResponseM2P.brokerInfos)
  return brokerinfos_.Add();
}
inline void RegisterResponseM2P::add_brokerinfos(const ::std::string& value) {
  brokerinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RegisterResponseM2P.brokerInfos)
}
#if LANG_CXX11
inline void RegisterResponseM2P::add_brokerinfos(::std::string&& value) {
  brokerinfos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RegisterResponseM2P.brokerInfos)
}
#endif
inline void RegisterResponseM2P::add_brokerinfos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  brokerinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RegisterResponseM2P.brokerInfos)
}
inline void RegisterResponseM2P::add_brokerinfos(const char* value, size_t size) {
  brokerinfos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RegisterResponseM2P.brokerInfos)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterResponseM2P::brokerinfos() const {
  // @@protoc_insertion_point(field_list:RegisterResponseM2P.brokerInfos)
  return brokerinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterResponseM2P::mutable_brokerinfos() {
  // @@protoc_insertion_point(field_mutable_list:RegisterResponseM2P.brokerInfos)
  return &brokerinfos_;
}

// optional .MasterAuthorizedInfo authorizedInfo = 6;
inline bool RegisterResponseM2P::has_authorizedinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResponseM2P::set_has_authorizedinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterResponseM2P::clear_has_authorizedinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterResponseM2P::clear_authorizedinfo() {
  if (authorizedinfo_ != NULL) authorizedinfo_->Clear();
  clear_has_authorizedinfo();
}
inline const ::MasterAuthorizedInfo& RegisterResponseM2P::_internal_authorizedinfo() const {
  return *authorizedinfo_;
}
inline const ::MasterAuthorizedInfo& RegisterResponseM2P::authorizedinfo() const {
  const ::MasterAuthorizedInfo* p = authorizedinfo_;
  // @@protoc_insertion_point(field_get:RegisterResponseM2P.authorizedInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterAuthorizedInfo*>(
      &::_MasterAuthorizedInfo_default_instance_);
}
inline ::MasterAuthorizedInfo* RegisterResponseM2P::release_authorizedinfo() {
  // @@protoc_insertion_point(field_release:RegisterResponseM2P.authorizedInfo)
  clear_has_authorizedinfo();
  ::MasterAuthorizedInfo* temp = authorizedinfo_;
  authorizedinfo_ = NULL;
  return temp;
}
inline ::MasterAuthorizedInfo* RegisterResponseM2P::mutable_authorizedinfo() {
  set_has_authorizedinfo();
  if (authorizedinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterAuthorizedInfo>(GetArenaNoVirtual());
    authorizedinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2P.authorizedInfo)
  return authorizedinfo_;
}
inline void RegisterResponseM2P::set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authorizedinfo_;
  }
  if (authorizedinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authorizedinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authorizedinfo, submessage_arena);
    }
    set_has_authorizedinfo();
  } else {
    clear_has_authorizedinfo();
  }
  authorizedinfo_ = authorizedinfo;
  // @@protoc_insertion_point(field_set_allocated:RegisterResponseM2P.authorizedInfo)
}

// -------------------------------------------------------------------

// HeartRequestP2M

// required string clientId = 1;
inline bool HeartRequestP2M::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartRequestP2M::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartRequestP2M::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartRequestP2M::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& HeartRequestP2M::clientid() const {
  // @@protoc_insertion_point(field_get:HeartRequestP2M.clientId)
  return clientid_.GetNoArena();
}
inline void HeartRequestP2M::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartRequestP2M.clientId)
}
#if LANG_CXX11
inline void HeartRequestP2M::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartRequestP2M.clientId)
}
#endif
inline void HeartRequestP2M::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartRequestP2M.clientId)
}
inline void HeartRequestP2M::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartRequestP2M.clientId)
}
inline ::std::string* HeartRequestP2M::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:HeartRequestP2M.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartRequestP2M::release_clientid() {
  // @@protoc_insertion_point(field_release:HeartRequestP2M.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartRequestP2M::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:HeartRequestP2M.clientId)
}

// required int64 brokerCheckSum = 2;
inline bool HeartRequestP2M::has_brokerchecksum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartRequestP2M::set_has_brokerchecksum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartRequestP2M::clear_has_brokerchecksum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartRequestP2M::clear_brokerchecksum() {
  brokerchecksum_ = GOOGLE_LONGLONG(0);
  clear_has_brokerchecksum();
}
inline ::google::protobuf::int64 HeartRequestP2M::brokerchecksum() const {
  // @@protoc_insertion_point(field_get:HeartRequestP2M.brokerCheckSum)
  return brokerchecksum_;
}
inline void HeartRequestP2M::set_brokerchecksum(::google::protobuf::int64 value) {
  set_has_brokerchecksum();
  brokerchecksum_ = value;
  // @@protoc_insertion_point(field_set:HeartRequestP2M.brokerCheckSum)
}

// required string hostName = 3;
inline bool HeartRequestP2M::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartRequestP2M::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartRequestP2M::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartRequestP2M::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& HeartRequestP2M::hostname() const {
  // @@protoc_insertion_point(field_get:HeartRequestP2M.hostName)
  return hostname_.GetNoArena();
}
inline void HeartRequestP2M::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartRequestP2M.hostName)
}
#if LANG_CXX11
inline void HeartRequestP2M::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartRequestP2M.hostName)
}
#endif
inline void HeartRequestP2M::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartRequestP2M.hostName)
}
inline void HeartRequestP2M::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartRequestP2M.hostName)
}
inline ::std::string* HeartRequestP2M::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:HeartRequestP2M.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartRequestP2M::release_hostname() {
  // @@protoc_insertion_point(field_release:HeartRequestP2M.hostName)
  if (!has_hostname()) {
    return NULL;
  }
  clear_has_hostname();
  return hostname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartRequestP2M::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:HeartRequestP2M.hostName)
}

// repeated string topicList = 4;
inline int HeartRequestP2M::topiclist_size() const {
  return topiclist_.size();
}
inline void HeartRequestP2M::clear_topiclist() {
  topiclist_.Clear();
}
inline const ::std::string& HeartRequestP2M::topiclist(int index) const {
  // @@protoc_insertion_point(field_get:HeartRequestP2M.topicList)
  return topiclist_.Get(index);
}
inline ::std::string* HeartRequestP2M::mutable_topiclist(int index) {
  // @@protoc_insertion_point(field_mutable:HeartRequestP2M.topicList)
  return topiclist_.Mutable(index);
}
inline void HeartRequestP2M::set_topiclist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:HeartRequestP2M.topicList)
  topiclist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HeartRequestP2M::set_topiclist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:HeartRequestP2M.topicList)
  topiclist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HeartRequestP2M::set_topiclist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiclist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HeartRequestP2M.topicList)
}
inline void HeartRequestP2M::set_topiclist(int index, const char* value, size_t size) {
  topiclist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HeartRequestP2M.topicList)
}
inline ::std::string* HeartRequestP2M::add_topiclist() {
  // @@protoc_insertion_point(field_add_mutable:HeartRequestP2M.topicList)
  return topiclist_.Add();
}
inline void HeartRequestP2M::add_topiclist(const ::std::string& value) {
  topiclist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HeartRequestP2M.topicList)
}
#if LANG_CXX11
inline void HeartRequestP2M::add_topiclist(::std::string&& value) {
  topiclist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HeartRequestP2M.topicList)
}
#endif
inline void HeartRequestP2M::add_topiclist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiclist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HeartRequestP2M.topicList)
}
inline void HeartRequestP2M::add_topiclist(const char* value, size_t size) {
  topiclist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HeartRequestP2M.topicList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartRequestP2M::topiclist() const {
  // @@protoc_insertion_point(field_list:HeartRequestP2M.topicList)
  return topiclist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartRequestP2M::mutable_topiclist() {
  // @@protoc_insertion_point(field_mutable_list:HeartRequestP2M.topicList)
  return &topiclist_;
}

// optional .MasterCertificateInfo authInfo = 5;
inline bool HeartRequestP2M::has_authinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartRequestP2M::set_has_authinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartRequestP2M::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartRequestP2M::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::MasterCertificateInfo& HeartRequestP2M::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::MasterCertificateInfo& HeartRequestP2M::authinfo() const {
  const ::MasterCertificateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:HeartRequestP2M.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterCertificateInfo*>(
      &::_MasterCertificateInfo_default_instance_);
}
inline ::MasterCertificateInfo* HeartRequestP2M::release_authinfo() {
  // @@protoc_insertion_point(field_release:HeartRequestP2M.authInfo)
  clear_has_authinfo();
  ::MasterCertificateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::MasterCertificateInfo* HeartRequestP2M::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterCertificateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HeartRequestP2M.authInfo)
  return authinfo_;
}
inline void HeartRequestP2M::set_allocated_authinfo(::MasterCertificateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:HeartRequestP2M.authInfo)
}

// -------------------------------------------------------------------

// HeartResponseM2P

// required bool success = 1;
inline bool HeartResponseM2P::has_success() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartResponseM2P::set_has_success() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartResponseM2P::clear_has_success() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartResponseM2P::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool HeartResponseM2P::success() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.success)
  return success_;
}
inline void HeartResponseM2P::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2P.success)
}

// required int32 errCode = 2;
inline bool HeartResponseM2P::has_errcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartResponseM2P::set_has_errcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartResponseM2P::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartResponseM2P::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 HeartResponseM2P::errcode() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.errCode)
  return errcode_;
}
inline void HeartResponseM2P::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2P.errCode)
}

// required string errMsg = 3;
inline bool HeartResponseM2P::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartResponseM2P::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartResponseM2P::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartResponseM2P::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errmsg();
}
inline const ::std::string& HeartResponseM2P::errmsg() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.errMsg)
  return errmsg_.GetNoArena();
}
inline void HeartResponseM2P::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartResponseM2P.errMsg)
}
#if LANG_CXX11
inline void HeartResponseM2P::set_errmsg(::std::string&& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartResponseM2P.errMsg)
}
#endif
inline void HeartResponseM2P::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartResponseM2P.errMsg)
}
inline void HeartResponseM2P::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartResponseM2P.errMsg)
}
inline ::std::string* HeartResponseM2P::mutable_errmsg() {
  set_has_errmsg();
  // @@protoc_insertion_point(field_mutable:HeartResponseM2P.errMsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartResponseM2P::release_errmsg() {
  // @@protoc_insertion_point(field_release:HeartResponseM2P.errMsg)
  if (!has_errmsg()) {
    return NULL;
  }
  clear_has_errmsg();
  return errmsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartResponseM2P::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2P.errMsg)
}

// required int64 brokerCheckSum = 4;
inline bool HeartResponseM2P::has_brokerchecksum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeartResponseM2P::set_has_brokerchecksum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeartResponseM2P::clear_has_brokerchecksum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeartResponseM2P::clear_brokerchecksum() {
  brokerchecksum_ = GOOGLE_LONGLONG(0);
  clear_has_brokerchecksum();
}
inline ::google::protobuf::int64 HeartResponseM2P::brokerchecksum() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.brokerCheckSum)
  return brokerchecksum_;
}
inline void HeartResponseM2P::set_brokerchecksum(::google::protobuf::int64 value) {
  set_has_brokerchecksum();
  brokerchecksum_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2P.brokerCheckSum)
}

// repeated string topicInfos = 5;
inline int HeartResponseM2P::topicinfos_size() const {
  return topicinfos_.size();
}
inline void HeartResponseM2P::clear_topicinfos() {
  topicinfos_.Clear();
}
inline const ::std::string& HeartResponseM2P::topicinfos(int index) const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.topicInfos)
  return topicinfos_.Get(index);
}
inline ::std::string* HeartResponseM2P::mutable_topicinfos(int index) {
  // @@protoc_insertion_point(field_mutable:HeartResponseM2P.topicInfos)
  return topicinfos_.Mutable(index);
}
inline void HeartResponseM2P::set_topicinfos(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:HeartResponseM2P.topicInfos)
  topicinfos_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HeartResponseM2P::set_topicinfos(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:HeartResponseM2P.topicInfos)
  topicinfos_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HeartResponseM2P::set_topicinfos(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topicinfos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HeartResponseM2P.topicInfos)
}
inline void HeartResponseM2P::set_topicinfos(int index, const char* value, size_t size) {
  topicinfos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HeartResponseM2P.topicInfos)
}
inline ::std::string* HeartResponseM2P::add_topicinfos() {
  // @@protoc_insertion_point(field_add_mutable:HeartResponseM2P.topicInfos)
  return topicinfos_.Add();
}
inline void HeartResponseM2P::add_topicinfos(const ::std::string& value) {
  topicinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HeartResponseM2P.topicInfos)
}
#if LANG_CXX11
inline void HeartResponseM2P::add_topicinfos(::std::string&& value) {
  topicinfos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HeartResponseM2P.topicInfos)
}
#endif
inline void HeartResponseM2P::add_topicinfos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topicinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HeartResponseM2P.topicInfos)
}
inline void HeartResponseM2P::add_topicinfos(const char* value, size_t size) {
  topicinfos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HeartResponseM2P.topicInfos)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartResponseM2P::topicinfos() const {
  // @@protoc_insertion_point(field_list:HeartResponseM2P.topicInfos)
  return topicinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartResponseM2P::mutable_topicinfos() {
  // @@protoc_insertion_point(field_mutable_list:HeartResponseM2P.topicInfos)
  return &topicinfos_;
}

// repeated string brokerInfos = 6;
inline int HeartResponseM2P::brokerinfos_size() const {
  return brokerinfos_.size();
}
inline void HeartResponseM2P::clear_brokerinfos() {
  brokerinfos_.Clear();
}
inline const ::std::string& HeartResponseM2P::brokerinfos(int index) const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.brokerInfos)
  return brokerinfos_.Get(index);
}
inline ::std::string* HeartResponseM2P::mutable_brokerinfos(int index) {
  // @@protoc_insertion_point(field_mutable:HeartResponseM2P.brokerInfos)
  return brokerinfos_.Mutable(index);
}
inline void HeartResponseM2P::set_brokerinfos(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:HeartResponseM2P.brokerInfos)
  brokerinfos_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HeartResponseM2P::set_brokerinfos(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:HeartResponseM2P.brokerInfos)
  brokerinfos_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HeartResponseM2P::set_brokerinfos(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  brokerinfos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HeartResponseM2P.brokerInfos)
}
inline void HeartResponseM2P::set_brokerinfos(int index, const char* value, size_t size) {
  brokerinfos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HeartResponseM2P.brokerInfos)
}
inline ::std::string* HeartResponseM2P::add_brokerinfos() {
  // @@protoc_insertion_point(field_add_mutable:HeartResponseM2P.brokerInfos)
  return brokerinfos_.Add();
}
inline void HeartResponseM2P::add_brokerinfos(const ::std::string& value) {
  brokerinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HeartResponseM2P.brokerInfos)
}
#if LANG_CXX11
inline void HeartResponseM2P::add_brokerinfos(::std::string&& value) {
  brokerinfos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HeartResponseM2P.brokerInfos)
}
#endif
inline void HeartResponseM2P::add_brokerinfos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  brokerinfos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HeartResponseM2P.brokerInfos)
}
inline void HeartResponseM2P::add_brokerinfos(const char* value, size_t size) {
  brokerinfos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HeartResponseM2P.brokerInfos)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartResponseM2P::brokerinfos() const {
  // @@protoc_insertion_point(field_list:HeartResponseM2P.brokerInfos)
  return brokerinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartResponseM2P::mutable_brokerinfos() {
  // @@protoc_insertion_point(field_mutable_list:HeartResponseM2P.brokerInfos)
  return &brokerinfos_;
}

// optional bool requireAuth = 7;
inline bool HeartResponseM2P::has_requireauth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeartResponseM2P::set_has_requireauth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeartResponseM2P::clear_has_requireauth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeartResponseM2P::clear_requireauth() {
  requireauth_ = false;
  clear_has_requireauth();
}
inline bool HeartResponseM2P::requireauth() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2P.requireAuth)
  return requireauth_;
}
inline void HeartResponseM2P::set_requireauth(bool value) {
  set_has_requireauth();
  requireauth_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2P.requireAuth)
}

// optional .MasterAuthorizedInfo authorizedInfo = 8;
inline bool HeartResponseM2P::has_authorizedinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartResponseM2P::set_has_authorizedinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartResponseM2P::clear_has_authorizedinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartResponseM2P::clear_authorizedinfo() {
  if (authorizedinfo_ != NULL) authorizedinfo_->Clear();
  clear_has_authorizedinfo();
}
inline const ::MasterAuthorizedInfo& HeartResponseM2P::_internal_authorizedinfo() const {
  return *authorizedinfo_;
}
inline const ::MasterAuthorizedInfo& HeartResponseM2P::authorizedinfo() const {
  const ::MasterAuthorizedInfo* p = authorizedinfo_;
  // @@protoc_insertion_point(field_get:HeartResponseM2P.authorizedInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterAuthorizedInfo*>(
      &::_MasterAuthorizedInfo_default_instance_);
}
inline ::MasterAuthorizedInfo* HeartResponseM2P::release_authorizedinfo() {
  // @@protoc_insertion_point(field_release:HeartResponseM2P.authorizedInfo)
  clear_has_authorizedinfo();
  ::MasterAuthorizedInfo* temp = authorizedinfo_;
  authorizedinfo_ = NULL;
  return temp;
}
inline ::MasterAuthorizedInfo* HeartResponseM2P::mutable_authorizedinfo() {
  set_has_authorizedinfo();
  if (authorizedinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterAuthorizedInfo>(GetArenaNoVirtual());
    authorizedinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HeartResponseM2P.authorizedInfo)
  return authorizedinfo_;
}
inline void HeartResponseM2P::set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authorizedinfo_;
  }
  if (authorizedinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authorizedinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authorizedinfo, submessage_arena);
    }
    set_has_authorizedinfo();
  } else {
    clear_has_authorizedinfo();
  }
  authorizedinfo_ = authorizedinfo;
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2P.authorizedInfo)
}

// -------------------------------------------------------------------

// CloseRequestP2M

// required string clientId = 1;
inline bool CloseRequestP2M::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseRequestP2M::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseRequestP2M::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseRequestP2M::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& CloseRequestP2M::clientid() const {
  // @@protoc_insertion_point(field_get:CloseRequestP2M.clientId)
  return clientid_.GetNoArena();
}
inline void CloseRequestP2M::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CloseRequestP2M.clientId)
}
#if LANG_CXX11
inline void CloseRequestP2M::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CloseRequestP2M.clientId)
}
#endif
inline void CloseRequestP2M::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CloseRequestP2M.clientId)
}
inline void CloseRequestP2M::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CloseRequestP2M.clientId)
}
inline ::std::string* CloseRequestP2M::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:CloseRequestP2M.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseRequestP2M::release_clientid() {
  // @@protoc_insertion_point(field_release:CloseRequestP2M.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseRequestP2M::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:CloseRequestP2M.clientId)
}

// optional .MasterCertificateInfo authInfo = 2;
inline bool CloseRequestP2M::has_authinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseRequestP2M::set_has_authinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseRequestP2M::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseRequestP2M::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::MasterCertificateInfo& CloseRequestP2M::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::MasterCertificateInfo& CloseRequestP2M::authinfo() const {
  const ::MasterCertificateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:CloseRequestP2M.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterCertificateInfo*>(
      &::_MasterCertificateInfo_default_instance_);
}
inline ::MasterCertificateInfo* CloseRequestP2M::release_authinfo() {
  // @@protoc_insertion_point(field_release:CloseRequestP2M.authInfo)
  clear_has_authinfo();
  ::MasterCertificateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::MasterCertificateInfo* CloseRequestP2M::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterCertificateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CloseRequestP2M.authInfo)
  return authinfo_;
}
inline void CloseRequestP2M::set_allocated_authinfo(::MasterCertificateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:CloseRequestP2M.authInfo)
}

// -------------------------------------------------------------------

// CloseResponseM2P

// required bool success = 1;
inline bool CloseResponseM2P::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseResponseM2P::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseResponseM2P::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseResponseM2P::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool CloseResponseM2P::success() const {
  // @@protoc_insertion_point(field_get:CloseResponseM2P.success)
  return success_;
}
inline void CloseResponseM2P::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:CloseResponseM2P.success)
}

// required int32 errCode = 2;
inline bool CloseResponseM2P::has_errcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CloseResponseM2P::set_has_errcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CloseResponseM2P::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CloseResponseM2P::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 CloseResponseM2P::errcode() const {
  // @@protoc_insertion_point(field_get:CloseResponseM2P.errCode)
  return errcode_;
}
inline void CloseResponseM2P::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:CloseResponseM2P.errCode)
}

// required string errMsg = 3;
inline bool CloseResponseM2P::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseResponseM2P::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseResponseM2P::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseResponseM2P::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errmsg();
}
inline const ::std::string& CloseResponseM2P::errmsg() const {
  // @@protoc_insertion_point(field_get:CloseResponseM2P.errMsg)
  return errmsg_.GetNoArena();
}
inline void CloseResponseM2P::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CloseResponseM2P.errMsg)
}
#if LANG_CXX11
inline void CloseResponseM2P::set_errmsg(::std::string&& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CloseResponseM2P.errMsg)
}
#endif
inline void CloseResponseM2P::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CloseResponseM2P.errMsg)
}
inline void CloseResponseM2P::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CloseResponseM2P.errMsg)
}
inline ::std::string* CloseResponseM2P::mutable_errmsg() {
  set_has_errmsg();
  // @@protoc_insertion_point(field_mutable:CloseResponseM2P.errMsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseResponseM2P::release_errmsg() {
  // @@protoc_insertion_point(field_release:CloseResponseM2P.errMsg)
  if (!has_errmsg()) {
    return NULL;
  }
  clear_has_errmsg();
  return errmsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseResponseM2P::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:CloseResponseM2P.errMsg)
}

// -------------------------------------------------------------------

// RegisterRequestC2M

// required string clientId = 1;
inline bool RegisterRequestC2M::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequestC2M::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequestC2M::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequestC2M::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& RegisterRequestC2M::clientid() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.clientId)
  return clientid_.GetNoArena();
}
inline void RegisterRequestC2M::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.clientId)
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestC2M.clientId)
}
#endif
inline void RegisterRequestC2M::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.clientId)
}
inline void RegisterRequestC2M::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.clientId)
}
inline ::std::string* RegisterRequestC2M::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestC2M::release_clientid() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestC2M::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.clientId)
}

// required string groupName = 2;
inline bool RegisterRequestC2M::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequestC2M::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequestC2M::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequestC2M::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupname();
}
inline const ::std::string& RegisterRequestC2M::groupname() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.groupName)
  return groupname_.GetNoArena();
}
inline void RegisterRequestC2M::set_groupname(const ::std::string& value) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.groupName)
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_groupname(::std::string&& value) {
  set_has_groupname();
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestC2M.groupName)
}
#endif
inline void RegisterRequestC2M::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.groupName)
}
inline void RegisterRequestC2M::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.groupName)
}
inline ::std::string* RegisterRequestC2M::mutable_groupname() {
  set_has_groupname();
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestC2M::release_groupname() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.groupName)
  if (!has_groupname()) {
    return NULL;
  }
  clear_has_groupname();
  return groupname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestC2M::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    set_has_groupname();
  } else {
    clear_has_groupname();
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.groupName)
}

// required string hostName = 3;
inline bool RegisterRequestC2M::has_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequestC2M::set_has_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequestC2M::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequestC2M::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& RegisterRequestC2M::hostname() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.hostName)
  return hostname_.GetNoArena();
}
inline void RegisterRequestC2M::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.hostName)
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_hostname(::std::string&& value) {
  set_has_hostname();
  hostname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestC2M.hostName)
}
#endif
inline void RegisterRequestC2M::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.hostName)
}
inline void RegisterRequestC2M::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.hostName)
}
inline ::std::string* RegisterRequestC2M::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestC2M::release_hostname() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.hostName)
  if (!has_hostname()) {
    return NULL;
  }
  clear_has_hostname();
  return hostname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestC2M::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.hostName)
}

// repeated string topicList = 4;
inline int RegisterRequestC2M::topiclist_size() const {
  return topiclist_.size();
}
inline void RegisterRequestC2M::clear_topiclist() {
  topiclist_.Clear();
}
inline const ::std::string& RegisterRequestC2M::topiclist(int index) const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.topicList)
  return topiclist_.Get(index);
}
inline ::std::string* RegisterRequestC2M::mutable_topiclist(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.topicList)
  return topiclist_.Mutable(index);
}
inline void RegisterRequestC2M::set_topiclist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.topicList)
  topiclist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_topiclist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.topicList)
  topiclist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterRequestC2M::set_topiclist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiclist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.topicList)
}
inline void RegisterRequestC2M::set_topiclist(int index, const char* value, size_t size) {
  topiclist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.topicList)
}
inline ::std::string* RegisterRequestC2M::add_topiclist() {
  // @@protoc_insertion_point(field_add_mutable:RegisterRequestC2M.topicList)
  return topiclist_.Add();
}
inline void RegisterRequestC2M::add_topiclist(const ::std::string& value) {
  topiclist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RegisterRequestC2M.topicList)
}
#if LANG_CXX11
inline void RegisterRequestC2M::add_topiclist(::std::string&& value) {
  topiclist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RegisterRequestC2M.topicList)
}
#endif
inline void RegisterRequestC2M::add_topiclist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiclist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RegisterRequestC2M.topicList)
}
inline void RegisterRequestC2M::add_topiclist(const char* value, size_t size) {
  topiclist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RegisterRequestC2M.topicList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterRequestC2M::topiclist() const {
  // @@protoc_insertion_point(field_list:RegisterRequestC2M.topicList)
  return topiclist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterRequestC2M::mutable_topiclist() {
  // @@protoc_insertion_point(field_mutable_list:RegisterRequestC2M.topicList)
  return &topiclist_;
}

// repeated string subscribeInfo = 5;
inline int RegisterRequestC2M::subscribeinfo_size() const {
  return subscribeinfo_.size();
}
inline void RegisterRequestC2M::clear_subscribeinfo() {
  subscribeinfo_.Clear();
}
inline const ::std::string& RegisterRequestC2M::subscribeinfo(int index) const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.subscribeInfo)
  return subscribeinfo_.Get(index);
}
inline ::std::string* RegisterRequestC2M::mutable_subscribeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.subscribeInfo)
  return subscribeinfo_.Mutable(index);
}
inline void RegisterRequestC2M::set_subscribeinfo(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.subscribeInfo)
  subscribeinfo_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_subscribeinfo(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.subscribeInfo)
  subscribeinfo_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterRequestC2M::set_subscribeinfo(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subscribeinfo_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.subscribeInfo)
}
inline void RegisterRequestC2M::set_subscribeinfo(int index, const char* value, size_t size) {
  subscribeinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.subscribeInfo)
}
inline ::std::string* RegisterRequestC2M::add_subscribeinfo() {
  // @@protoc_insertion_point(field_add_mutable:RegisterRequestC2M.subscribeInfo)
  return subscribeinfo_.Add();
}
inline void RegisterRequestC2M::add_subscribeinfo(const ::std::string& value) {
  subscribeinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RegisterRequestC2M.subscribeInfo)
}
#if LANG_CXX11
inline void RegisterRequestC2M::add_subscribeinfo(::std::string&& value) {
  subscribeinfo_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RegisterRequestC2M.subscribeInfo)
}
#endif
inline void RegisterRequestC2M::add_subscribeinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subscribeinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RegisterRequestC2M.subscribeInfo)
}
inline void RegisterRequestC2M::add_subscribeinfo(const char* value, size_t size) {
  subscribeinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RegisterRequestC2M.subscribeInfo)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterRequestC2M::subscribeinfo() const {
  // @@protoc_insertion_point(field_list:RegisterRequestC2M.subscribeInfo)
  return subscribeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterRequestC2M::mutable_subscribeinfo() {
  // @@protoc_insertion_point(field_mutable_list:RegisterRequestC2M.subscribeInfo)
  return &subscribeinfo_;
}

// repeated string topicCondition = 6;
inline int RegisterRequestC2M::topiccondition_size() const {
  return topiccondition_.size();
}
inline void RegisterRequestC2M::clear_topiccondition() {
  topiccondition_.Clear();
}
inline const ::std::string& RegisterRequestC2M::topiccondition(int index) const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.topicCondition)
  return topiccondition_.Get(index);
}
inline ::std::string* RegisterRequestC2M::mutable_topiccondition(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.topicCondition)
  return topiccondition_.Mutable(index);
}
inline void RegisterRequestC2M::set_topiccondition(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.topicCondition)
  topiccondition_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_topiccondition(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.topicCondition)
  topiccondition_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterRequestC2M::set_topiccondition(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiccondition_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.topicCondition)
}
inline void RegisterRequestC2M::set_topiccondition(int index, const char* value, size_t size) {
  topiccondition_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.topicCondition)
}
inline ::std::string* RegisterRequestC2M::add_topiccondition() {
  // @@protoc_insertion_point(field_add_mutable:RegisterRequestC2M.topicCondition)
  return topiccondition_.Add();
}
inline void RegisterRequestC2M::add_topiccondition(const ::std::string& value) {
  topiccondition_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RegisterRequestC2M.topicCondition)
}
#if LANG_CXX11
inline void RegisterRequestC2M::add_topiccondition(::std::string&& value) {
  topiccondition_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RegisterRequestC2M.topicCondition)
}
#endif
inline void RegisterRequestC2M::add_topiccondition(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topiccondition_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RegisterRequestC2M.topicCondition)
}
inline void RegisterRequestC2M::add_topiccondition(const char* value, size_t size) {
  topiccondition_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RegisterRequestC2M.topicCondition)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterRequestC2M::topiccondition() const {
  // @@protoc_insertion_point(field_list:RegisterRequestC2M.topicCondition)
  return topiccondition_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterRequestC2M::mutable_topiccondition() {
  // @@protoc_insertion_point(field_mutable_list:RegisterRequestC2M.topicCondition)
  return &topiccondition_;
}

// optional bool requireBound = 7;
inline bool RegisterRequestC2M::has_requirebound() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegisterRequestC2M::set_has_requirebound() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegisterRequestC2M::clear_has_requirebound() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegisterRequestC2M::clear_requirebound() {
  requirebound_ = false;
  clear_has_requirebound();
}
inline bool RegisterRequestC2M::requirebound() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.requireBound)
  return requirebound_;
}
inline void RegisterRequestC2M::set_requirebound(bool value) {
  set_has_requirebound();
  requirebound_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.requireBound)
}

// optional int64 sessionTime = 8;
inline bool RegisterRequestC2M::has_sessiontime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterRequestC2M::set_has_sessiontime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterRequestC2M::clear_has_sessiontime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterRequestC2M::clear_sessiontime() {
  sessiontime_ = GOOGLE_LONGLONG(0);
  clear_has_sessiontime();
}
inline ::google::protobuf::int64 RegisterRequestC2M::sessiontime() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.sessionTime)
  return sessiontime_;
}
inline void RegisterRequestC2M::set_sessiontime(::google::protobuf::int64 value) {
  set_has_sessiontime();
  sessiontime_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.sessionTime)
}

// optional string sessionKey = 9;
inline bool RegisterRequestC2M::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequestC2M::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRequestC2M::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRequestC2M::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionkey();
}
inline const ::std::string& RegisterRequestC2M::sessionkey() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.sessionKey)
  return sessionkey_.GetNoArena();
}
inline void RegisterRequestC2M::set_sessionkey(const ::std::string& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.sessionKey)
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_sessionkey(::std::string&& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestC2M.sessionKey)
}
#endif
inline void RegisterRequestC2M::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.sessionKey)
}
inline void RegisterRequestC2M::set_sessionkey(const char* value, size_t size) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.sessionKey)
}
inline ::std::string* RegisterRequestC2M::mutable_sessionkey() {
  set_has_sessionkey();
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.sessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestC2M::release_sessionkey() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.sessionKey)
  if (!has_sessionkey()) {
    return NULL;
  }
  clear_has_sessionkey();
  return sessionkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestC2M::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.sessionKey)
}

// optional int32 totalCount = 10;
inline bool RegisterRequestC2M::has_totalcount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegisterRequestC2M::set_has_totalcount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegisterRequestC2M::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegisterRequestC2M::clear_totalcount() {
  totalcount_ = 0;
  clear_has_totalcount();
}
inline ::google::protobuf::int32 RegisterRequestC2M::totalcount() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.totalCount)
  return totalcount_;
}
inline void RegisterRequestC2M::set_totalcount(::google::protobuf::int32 value) {
  set_has_totalcount();
  totalcount_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.totalCount)
}

// optional string requiredPartition = 11;
inline bool RegisterRequestC2M::has_requiredpartition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRequestC2M::set_has_requiredpartition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRequestC2M::clear_has_requiredpartition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRequestC2M::clear_requiredpartition() {
  requiredpartition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requiredpartition();
}
inline const ::std::string& RegisterRequestC2M::requiredpartition() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.requiredPartition)
  return requiredpartition_.GetNoArena();
}
inline void RegisterRequestC2M::set_requiredpartition(const ::std::string& value) {
  set_has_requiredpartition();
  requiredpartition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.requiredPartition)
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_requiredpartition(::std::string&& value) {
  set_has_requiredpartition();
  requiredpartition_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestC2M.requiredPartition)
}
#endif
inline void RegisterRequestC2M::set_requiredpartition(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_requiredpartition();
  requiredpartition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.requiredPartition)
}
inline void RegisterRequestC2M::set_requiredpartition(const char* value, size_t size) {
  set_has_requiredpartition();
  requiredpartition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.requiredPartition)
}
inline ::std::string* RegisterRequestC2M::mutable_requiredpartition() {
  set_has_requiredpartition();
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.requiredPartition)
  return requiredpartition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestC2M::release_requiredpartition() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.requiredPartition)
  if (!has_requiredpartition()) {
    return NULL;
  }
  clear_has_requiredpartition();
  return requiredpartition_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestC2M::set_allocated_requiredpartition(::std::string* requiredpartition) {
  if (requiredpartition != NULL) {
    set_has_requiredpartition();
  } else {
    clear_has_requiredpartition();
  }
  requiredpartition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requiredpartition);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.requiredPartition)
}

// optional bool notAllocated = 12;
inline bool RegisterRequestC2M::has_notallocated() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegisterRequestC2M::set_has_notallocated() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegisterRequestC2M::clear_has_notallocated() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegisterRequestC2M::clear_notallocated() {
  notallocated_ = false;
  clear_has_notallocated();
}
inline bool RegisterRequestC2M::notallocated() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.notAllocated)
  return notallocated_;
}
inline void RegisterRequestC2M::set_notallocated(bool value) {
  set_has_notallocated();
  notallocated_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.notAllocated)
}

// optional bool selectBig = 13;
inline bool RegisterRequestC2M::has_selectbig() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RegisterRequestC2M::set_has_selectbig() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RegisterRequestC2M::clear_has_selectbig() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RegisterRequestC2M::clear_selectbig() {
  selectbig_ = false;
  clear_has_selectbig();
}
inline bool RegisterRequestC2M::selectbig() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.selectBig)
  return selectbig_;
}
inline void RegisterRequestC2M::set_selectbig(bool value) {
  set_has_selectbig();
  selectbig_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.selectBig)
}

// optional int64 groupFlowCheckId = 14;
inline bool RegisterRequestC2M::has_groupflowcheckid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RegisterRequestC2M::set_has_groupflowcheckid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RegisterRequestC2M::clear_has_groupflowcheckid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RegisterRequestC2M::clear_groupflowcheckid() {
  groupflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_groupflowcheckid();
}
inline ::google::protobuf::int64 RegisterRequestC2M::groupflowcheckid() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.groupFlowCheckId)
  return groupflowcheckid_;
}
inline void RegisterRequestC2M::set_groupflowcheckid(::google::protobuf::int64 value) {
  set_has_groupflowcheckid();
  groupflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.groupFlowCheckId)
}

// optional int64 defFlowCheckId = 15;
inline bool RegisterRequestC2M::has_defflowcheckid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RegisterRequestC2M::set_has_defflowcheckid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RegisterRequestC2M::clear_has_defflowcheckid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RegisterRequestC2M::clear_defflowcheckid() {
  defflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_defflowcheckid();
}
inline ::google::protobuf::int64 RegisterRequestC2M::defflowcheckid() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.defFlowCheckId)
  return defflowcheckid_;
}
inline void RegisterRequestC2M::set_defflowcheckid(::google::protobuf::int64 value) {
  set_has_defflowcheckid();
  defflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.defFlowCheckId)
}

// optional int64 ssdStoreId = 16;
inline bool RegisterRequestC2M::has_ssdstoreid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RegisterRequestC2M::set_has_ssdstoreid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RegisterRequestC2M::clear_has_ssdstoreid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RegisterRequestC2M::clear_ssdstoreid() {
  ssdstoreid_ = GOOGLE_LONGLONG(0);
  clear_has_ssdstoreid();
}
inline ::google::protobuf::int64 RegisterRequestC2M::ssdstoreid() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.ssdStoreId)
  return ssdstoreid_;
}
inline void RegisterRequestC2M::set_ssdstoreid(::google::protobuf::int64 value) {
  set_has_ssdstoreid();
  ssdstoreid_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.ssdStoreId)
}

// optional int32 qryPriorityId = 17;
inline bool RegisterRequestC2M::has_qrypriorityid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RegisterRequestC2M::set_has_qrypriorityid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RegisterRequestC2M::clear_has_qrypriorityid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RegisterRequestC2M::clear_qrypriorityid() {
  qrypriorityid_ = 0;
  clear_has_qrypriorityid();
}
inline ::google::protobuf::int32 RegisterRequestC2M::qrypriorityid() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.qryPriorityId)
  return qrypriorityid_;
}
inline void RegisterRequestC2M::set_qrypriorityid(::google::protobuf::int32 value) {
  set_has_qrypriorityid();
  qrypriorityid_ = value;
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.qryPriorityId)
}

// optional .MasterCertificateInfo authInfo = 18;
inline bool RegisterRequestC2M::has_authinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterRequestC2M::set_has_authinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterRequestC2M::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterRequestC2M::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::MasterCertificateInfo& RegisterRequestC2M::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::MasterCertificateInfo& RegisterRequestC2M::authinfo() const {
  const ::MasterCertificateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterCertificateInfo*>(
      &::_MasterCertificateInfo_default_instance_);
}
inline ::MasterCertificateInfo* RegisterRequestC2M::release_authinfo() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.authInfo)
  clear_has_authinfo();
  ::MasterCertificateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::MasterCertificateInfo* RegisterRequestC2M::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterCertificateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.authInfo)
  return authinfo_;
}
inline void RegisterRequestC2M::set_allocated_authinfo(::MasterCertificateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.authInfo)
}

// optional string jdkVersion = 19;
inline bool RegisterRequestC2M::has_jdkversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterRequestC2M::set_has_jdkversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterRequestC2M::clear_has_jdkversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterRequestC2M::clear_jdkversion() {
  jdkversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jdkversion();
}
inline const ::std::string& RegisterRequestC2M::jdkversion() const {
  // @@protoc_insertion_point(field_get:RegisterRequestC2M.jdkVersion)
  return jdkversion_.GetNoArena();
}
inline void RegisterRequestC2M::set_jdkversion(const ::std::string& value) {
  set_has_jdkversion();
  jdkversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterRequestC2M.jdkVersion)
}
#if LANG_CXX11
inline void RegisterRequestC2M::set_jdkversion(::std::string&& value) {
  set_has_jdkversion();
  jdkversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterRequestC2M.jdkVersion)
}
#endif
inline void RegisterRequestC2M::set_jdkversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jdkversion();
  jdkversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterRequestC2M.jdkVersion)
}
inline void RegisterRequestC2M::set_jdkversion(const char* value, size_t size) {
  set_has_jdkversion();
  jdkversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterRequestC2M.jdkVersion)
}
inline ::std::string* RegisterRequestC2M::mutable_jdkversion() {
  set_has_jdkversion();
  // @@protoc_insertion_point(field_mutable:RegisterRequestC2M.jdkVersion)
  return jdkversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequestC2M::release_jdkversion() {
  // @@protoc_insertion_point(field_release:RegisterRequestC2M.jdkVersion)
  if (!has_jdkversion()) {
    return NULL;
  }
  clear_has_jdkversion();
  return jdkversion_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequestC2M::set_allocated_jdkversion(::std::string* jdkversion) {
  if (jdkversion != NULL) {
    set_has_jdkversion();
  } else {
    clear_has_jdkversion();
  }
  jdkversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jdkversion);
  // @@protoc_insertion_point(field_set_allocated:RegisterRequestC2M.jdkVersion)
}

// -------------------------------------------------------------------

// RegisterResponseM2C

// required bool success = 1;
inline bool RegisterResponseM2C::has_success() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegisterResponseM2C::set_has_success() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegisterResponseM2C::clear_has_success() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegisterResponseM2C::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool RegisterResponseM2C::success() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.success)
  return success_;
}
inline void RegisterResponseM2C::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.success)
}

// required int32 errCode = 2;
inline bool RegisterResponseM2C::has_errcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterResponseM2C::set_has_errcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterResponseM2C::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterResponseM2C::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 RegisterResponseM2C::errcode() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.errCode)
  return errcode_;
}
inline void RegisterResponseM2C::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.errCode)
}

// required string errMsg = 3;
inline bool RegisterResponseM2C::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponseM2C::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponseM2C::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponseM2C::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errmsg();
}
inline const ::std::string& RegisterResponseM2C::errmsg() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.errMsg)
  return errmsg_.GetNoArena();
}
inline void RegisterResponseM2C::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.errMsg)
}
#if LANG_CXX11
inline void RegisterResponseM2C::set_errmsg(::std::string&& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterResponseM2C.errMsg)
}
#endif
inline void RegisterResponseM2C::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterResponseM2C.errMsg)
}
inline void RegisterResponseM2C::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterResponseM2C.errMsg)
}
inline ::std::string* RegisterResponseM2C::mutable_errmsg() {
  set_has_errmsg();
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2C.errMsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponseM2C::release_errmsg() {
  // @@protoc_insertion_point(field_release:RegisterResponseM2C.errMsg)
  if (!has_errmsg()) {
    return NULL;
  }
  clear_has_errmsg();
  return errmsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponseM2C::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:RegisterResponseM2C.errMsg)
}

// repeated string topicInfo = 4;
inline int RegisterResponseM2C::topicinfo_size() const {
  return topicinfo_.size();
}
inline void RegisterResponseM2C::clear_topicinfo() {
  topicinfo_.Clear();
}
inline const ::std::string& RegisterResponseM2C::topicinfo(int index) const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.topicInfo)
  return topicinfo_.Get(index);
}
inline ::std::string* RegisterResponseM2C::mutable_topicinfo(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2C.topicInfo)
  return topicinfo_.Mutable(index);
}
inline void RegisterResponseM2C::set_topicinfo(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.topicInfo)
  topicinfo_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterResponseM2C::set_topicinfo(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.topicInfo)
  topicinfo_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterResponseM2C::set_topicinfo(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topicinfo_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RegisterResponseM2C.topicInfo)
}
inline void RegisterResponseM2C::set_topicinfo(int index, const char* value, size_t size) {
  topicinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegisterResponseM2C.topicInfo)
}
inline ::std::string* RegisterResponseM2C::add_topicinfo() {
  // @@protoc_insertion_point(field_add_mutable:RegisterResponseM2C.topicInfo)
  return topicinfo_.Add();
}
inline void RegisterResponseM2C::add_topicinfo(const ::std::string& value) {
  topicinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:RegisterResponseM2C.topicInfo)
}
#if LANG_CXX11
inline void RegisterResponseM2C::add_topicinfo(::std::string&& value) {
  topicinfo_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:RegisterResponseM2C.topicInfo)
}
#endif
inline void RegisterResponseM2C::add_topicinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  topicinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RegisterResponseM2C.topicInfo)
}
inline void RegisterResponseM2C::add_topicinfo(const char* value, size_t size) {
  topicinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RegisterResponseM2C.topicInfo)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterResponseM2C::topicinfo() const {
  // @@protoc_insertion_point(field_list:RegisterResponseM2C.topicInfo)
  return topicinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterResponseM2C::mutable_topicinfo() {
  // @@protoc_insertion_point(field_mutable_list:RegisterResponseM2C.topicInfo)
  return &topicinfo_;
}

// optional bool notAllocated = 5;
inline bool RegisterResponseM2C::has_notallocated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegisterResponseM2C::set_has_notallocated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegisterResponseM2C::clear_has_notallocated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegisterResponseM2C::clear_notallocated() {
  notallocated_ = false;
  clear_has_notallocated();
}
inline bool RegisterResponseM2C::notallocated() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.notAllocated)
  return notallocated_;
}
inline void RegisterResponseM2C::set_notallocated(bool value) {
  set_has_notallocated();
  notallocated_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.notAllocated)
}

// optional int64 defFlowCheckId = 6;
inline bool RegisterResponseM2C::has_defflowcheckid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegisterResponseM2C::set_has_defflowcheckid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegisterResponseM2C::clear_has_defflowcheckid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegisterResponseM2C::clear_defflowcheckid() {
  defflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_defflowcheckid();
}
inline ::google::protobuf::int64 RegisterResponseM2C::defflowcheckid() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.defFlowCheckId)
  return defflowcheckid_;
}
inline void RegisterResponseM2C::set_defflowcheckid(::google::protobuf::int64 value) {
  set_has_defflowcheckid();
  defflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.defFlowCheckId)
}

// optional string defFlowControlInfo = 7;
inline bool RegisterResponseM2C::has_defflowcontrolinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResponseM2C::set_has_defflowcontrolinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterResponseM2C::clear_has_defflowcontrolinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterResponseM2C::clear_defflowcontrolinfo() {
  defflowcontrolinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_defflowcontrolinfo();
}
inline const ::std::string& RegisterResponseM2C::defflowcontrolinfo() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.defFlowControlInfo)
  return defflowcontrolinfo_.GetNoArena();
}
inline void RegisterResponseM2C::set_defflowcontrolinfo(const ::std::string& value) {
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.defFlowControlInfo)
}
#if LANG_CXX11
inline void RegisterResponseM2C::set_defflowcontrolinfo(::std::string&& value) {
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterResponseM2C.defFlowControlInfo)
}
#endif
inline void RegisterResponseM2C::set_defflowcontrolinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterResponseM2C.defFlowControlInfo)
}
inline void RegisterResponseM2C::set_defflowcontrolinfo(const char* value, size_t size) {
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterResponseM2C.defFlowControlInfo)
}
inline ::std::string* RegisterResponseM2C::mutable_defflowcontrolinfo() {
  set_has_defflowcontrolinfo();
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2C.defFlowControlInfo)
  return defflowcontrolinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponseM2C::release_defflowcontrolinfo() {
  // @@protoc_insertion_point(field_release:RegisterResponseM2C.defFlowControlInfo)
  if (!has_defflowcontrolinfo()) {
    return NULL;
  }
  clear_has_defflowcontrolinfo();
  return defflowcontrolinfo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponseM2C::set_allocated_defflowcontrolinfo(::std::string* defflowcontrolinfo) {
  if (defflowcontrolinfo != NULL) {
    set_has_defflowcontrolinfo();
  } else {
    clear_has_defflowcontrolinfo();
  }
  defflowcontrolinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), defflowcontrolinfo);
  // @@protoc_insertion_point(field_set_allocated:RegisterResponseM2C.defFlowControlInfo)
}

// optional int64 groupFlowCheckId = 8;
inline bool RegisterResponseM2C::has_groupflowcheckid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegisterResponseM2C::set_has_groupflowcheckid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegisterResponseM2C::clear_has_groupflowcheckid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegisterResponseM2C::clear_groupflowcheckid() {
  groupflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_groupflowcheckid();
}
inline ::google::protobuf::int64 RegisterResponseM2C::groupflowcheckid() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.groupFlowCheckId)
  return groupflowcheckid_;
}
inline void RegisterResponseM2C::set_groupflowcheckid(::google::protobuf::int64 value) {
  set_has_groupflowcheckid();
  groupflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.groupFlowCheckId)
}

// optional string groupFlowControlInfo = 9;
inline bool RegisterResponseM2C::has_groupflowcontrolinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterResponseM2C::set_has_groupflowcontrolinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterResponseM2C::clear_has_groupflowcontrolinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterResponseM2C::clear_groupflowcontrolinfo() {
  groupflowcontrolinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupflowcontrolinfo();
}
inline const ::std::string& RegisterResponseM2C::groupflowcontrolinfo() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.groupFlowControlInfo)
  return groupflowcontrolinfo_.GetNoArena();
}
inline void RegisterResponseM2C::set_groupflowcontrolinfo(const ::std::string& value) {
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.groupFlowControlInfo)
}
#if LANG_CXX11
inline void RegisterResponseM2C::set_groupflowcontrolinfo(::std::string&& value) {
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RegisterResponseM2C.groupFlowControlInfo)
}
#endif
inline void RegisterResponseM2C::set_groupflowcontrolinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RegisterResponseM2C.groupFlowControlInfo)
}
inline void RegisterResponseM2C::set_groupflowcontrolinfo(const char* value, size_t size) {
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RegisterResponseM2C.groupFlowControlInfo)
}
inline ::std::string* RegisterResponseM2C::mutable_groupflowcontrolinfo() {
  set_has_groupflowcontrolinfo();
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2C.groupFlowControlInfo)
  return groupflowcontrolinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponseM2C::release_groupflowcontrolinfo() {
  // @@protoc_insertion_point(field_release:RegisterResponseM2C.groupFlowControlInfo)
  if (!has_groupflowcontrolinfo()) {
    return NULL;
  }
  clear_has_groupflowcontrolinfo();
  return groupflowcontrolinfo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponseM2C::set_allocated_groupflowcontrolinfo(::std::string* groupflowcontrolinfo) {
  if (groupflowcontrolinfo != NULL) {
    set_has_groupflowcontrolinfo();
  } else {
    clear_has_groupflowcontrolinfo();
  }
  groupflowcontrolinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupflowcontrolinfo);
  // @@protoc_insertion_point(field_set_allocated:RegisterResponseM2C.groupFlowControlInfo)
}

// optional int64 ssdStoreId = 10;
inline bool RegisterResponseM2C::has_ssdstoreid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegisterResponseM2C::set_has_ssdstoreid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegisterResponseM2C::clear_has_ssdstoreid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegisterResponseM2C::clear_ssdstoreid() {
  ssdstoreid_ = GOOGLE_LONGLONG(0);
  clear_has_ssdstoreid();
}
inline ::google::protobuf::int64 RegisterResponseM2C::ssdstoreid() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.ssdStoreId)
  return ssdstoreid_;
}
inline void RegisterResponseM2C::set_ssdstoreid(::google::protobuf::int64 value) {
  set_has_ssdstoreid();
  ssdstoreid_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.ssdStoreId)
}

// optional int32 qryPriorityId = 11;
inline bool RegisterResponseM2C::has_qrypriorityid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegisterResponseM2C::set_has_qrypriorityid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegisterResponseM2C::clear_has_qrypriorityid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegisterResponseM2C::clear_qrypriorityid() {
  qrypriorityid_ = 0;
  clear_has_qrypriorityid();
}
inline ::google::protobuf::int32 RegisterResponseM2C::qrypriorityid() const {
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.qryPriorityId)
  return qrypriorityid_;
}
inline void RegisterResponseM2C::set_qrypriorityid(::google::protobuf::int32 value) {
  set_has_qrypriorityid();
  qrypriorityid_ = value;
  // @@protoc_insertion_point(field_set:RegisterResponseM2C.qryPriorityId)
}

// optional .MasterAuthorizedInfo authorizedInfo = 12;
inline bool RegisterResponseM2C::has_authorizedinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterResponseM2C::set_has_authorizedinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterResponseM2C::clear_has_authorizedinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterResponseM2C::clear_authorizedinfo() {
  if (authorizedinfo_ != NULL) authorizedinfo_->Clear();
  clear_has_authorizedinfo();
}
inline const ::MasterAuthorizedInfo& RegisterResponseM2C::_internal_authorizedinfo() const {
  return *authorizedinfo_;
}
inline const ::MasterAuthorizedInfo& RegisterResponseM2C::authorizedinfo() const {
  const ::MasterAuthorizedInfo* p = authorizedinfo_;
  // @@protoc_insertion_point(field_get:RegisterResponseM2C.authorizedInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterAuthorizedInfo*>(
      &::_MasterAuthorizedInfo_default_instance_);
}
inline ::MasterAuthorizedInfo* RegisterResponseM2C::release_authorizedinfo() {
  // @@protoc_insertion_point(field_release:RegisterResponseM2C.authorizedInfo)
  clear_has_authorizedinfo();
  ::MasterAuthorizedInfo* temp = authorizedinfo_;
  authorizedinfo_ = NULL;
  return temp;
}
inline ::MasterAuthorizedInfo* RegisterResponseM2C::mutable_authorizedinfo() {
  set_has_authorizedinfo();
  if (authorizedinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterAuthorizedInfo>(GetArenaNoVirtual());
    authorizedinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RegisterResponseM2C.authorizedInfo)
  return authorizedinfo_;
}
inline void RegisterResponseM2C::set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authorizedinfo_;
  }
  if (authorizedinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authorizedinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authorizedinfo, submessage_arena);
    }
    set_has_authorizedinfo();
  } else {
    clear_has_authorizedinfo();
  }
  authorizedinfo_ = authorizedinfo;
  // @@protoc_insertion_point(field_set_allocated:RegisterResponseM2C.authorizedInfo)
}

// -------------------------------------------------------------------

// HeartRequestC2M

// required string clientId = 1;
inline bool HeartRequestC2M::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartRequestC2M::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartRequestC2M::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartRequestC2M::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& HeartRequestC2M::clientid() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.clientId)
  return clientid_.GetNoArena();
}
inline void HeartRequestC2M::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartRequestC2M.clientId)
}
#if LANG_CXX11
inline void HeartRequestC2M::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartRequestC2M.clientId)
}
#endif
inline void HeartRequestC2M::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartRequestC2M.clientId)
}
inline void HeartRequestC2M::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartRequestC2M.clientId)
}
inline ::std::string* HeartRequestC2M::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:HeartRequestC2M.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartRequestC2M::release_clientid() {
  // @@protoc_insertion_point(field_release:HeartRequestC2M.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartRequestC2M::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:HeartRequestC2M.clientId)
}

// required string groupName = 2;
inline bool HeartRequestC2M::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartRequestC2M::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartRequestC2M::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartRequestC2M::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupname();
}
inline const ::std::string& HeartRequestC2M::groupname() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.groupName)
  return groupname_.GetNoArena();
}
inline void HeartRequestC2M::set_groupname(const ::std::string& value) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartRequestC2M.groupName)
}
#if LANG_CXX11
inline void HeartRequestC2M::set_groupname(::std::string&& value) {
  set_has_groupname();
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartRequestC2M.groupName)
}
#endif
inline void HeartRequestC2M::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartRequestC2M.groupName)
}
inline void HeartRequestC2M::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartRequestC2M.groupName)
}
inline ::std::string* HeartRequestC2M::mutable_groupname() {
  set_has_groupname();
  // @@protoc_insertion_point(field_mutable:HeartRequestC2M.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartRequestC2M::release_groupname() {
  // @@protoc_insertion_point(field_release:HeartRequestC2M.groupName)
  if (!has_groupname()) {
    return NULL;
  }
  clear_has_groupname();
  return groupname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartRequestC2M::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    set_has_groupname();
  } else {
    clear_has_groupname();
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:HeartRequestC2M.groupName)
}

// repeated string subscribeInfo = 3;
inline int HeartRequestC2M::subscribeinfo_size() const {
  return subscribeinfo_.size();
}
inline void HeartRequestC2M::clear_subscribeinfo() {
  subscribeinfo_.Clear();
}
inline const ::std::string& HeartRequestC2M::subscribeinfo(int index) const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.subscribeInfo)
  return subscribeinfo_.Get(index);
}
inline ::std::string* HeartRequestC2M::mutable_subscribeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:HeartRequestC2M.subscribeInfo)
  return subscribeinfo_.Mutable(index);
}
inline void HeartRequestC2M::set_subscribeinfo(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:HeartRequestC2M.subscribeInfo)
  subscribeinfo_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HeartRequestC2M::set_subscribeinfo(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:HeartRequestC2M.subscribeInfo)
  subscribeinfo_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HeartRequestC2M::set_subscribeinfo(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subscribeinfo_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HeartRequestC2M.subscribeInfo)
}
inline void HeartRequestC2M::set_subscribeinfo(int index, const char* value, size_t size) {
  subscribeinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HeartRequestC2M.subscribeInfo)
}
inline ::std::string* HeartRequestC2M::add_subscribeinfo() {
  // @@protoc_insertion_point(field_add_mutable:HeartRequestC2M.subscribeInfo)
  return subscribeinfo_.Add();
}
inline void HeartRequestC2M::add_subscribeinfo(const ::std::string& value) {
  subscribeinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HeartRequestC2M.subscribeInfo)
}
#if LANG_CXX11
inline void HeartRequestC2M::add_subscribeinfo(::std::string&& value) {
  subscribeinfo_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HeartRequestC2M.subscribeInfo)
}
#endif
inline void HeartRequestC2M::add_subscribeinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subscribeinfo_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HeartRequestC2M.subscribeInfo)
}
inline void HeartRequestC2M::add_subscribeinfo(const char* value, size_t size) {
  subscribeinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HeartRequestC2M.subscribeInfo)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartRequestC2M::subscribeinfo() const {
  // @@protoc_insertion_point(field_list:HeartRequestC2M.subscribeInfo)
  return subscribeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartRequestC2M::mutable_subscribeinfo() {
  // @@protoc_insertion_point(field_mutable_list:HeartRequestC2M.subscribeInfo)
  return &subscribeinfo_;
}

// required bool reportSubscribeInfo = 4;
inline bool HeartRequestC2M::has_reportsubscribeinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeartRequestC2M::set_has_reportsubscribeinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeartRequestC2M::clear_has_reportsubscribeinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeartRequestC2M::clear_reportsubscribeinfo() {
  reportsubscribeinfo_ = false;
  clear_has_reportsubscribeinfo();
}
inline bool HeartRequestC2M::reportsubscribeinfo() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.reportSubscribeInfo)
  return reportsubscribeinfo_;
}
inline void HeartRequestC2M::set_reportsubscribeinfo(bool value) {
  set_has_reportsubscribeinfo();
  reportsubscribeinfo_ = value;
  // @@protoc_insertion_point(field_set:HeartRequestC2M.reportSubscribeInfo)
}

// optional .EventProto event = 5;
inline bool HeartRequestC2M::has_event() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartRequestC2M::set_has_event() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartRequestC2M::clear_has_event() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartRequestC2M::clear_event() {
  if (event_ != NULL) event_->Clear();
  clear_has_event();
}
inline const ::EventProto& HeartRequestC2M::_internal_event() const {
  return *event_;
}
inline const ::EventProto& HeartRequestC2M::event() const {
  const ::EventProto* p = event_;
  // @@protoc_insertion_point(field_get:HeartRequestC2M.event)
  return p != NULL ? *p : *reinterpret_cast<const ::EventProto*>(
      &::_EventProto_default_instance_);
}
inline ::EventProto* HeartRequestC2M::release_event() {
  // @@protoc_insertion_point(field_release:HeartRequestC2M.event)
  clear_has_event();
  ::EventProto* temp = event_;
  event_ = NULL;
  return temp;
}
inline ::EventProto* HeartRequestC2M::mutable_event() {
  set_has_event();
  if (event_ == NULL) {
    auto* p = CreateMaybeMessage<::EventProto>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HeartRequestC2M.event)
  return event_;
}
inline void HeartRequestC2M::set_allocated_event(::EventProto* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_;
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    set_has_event();
  } else {
    clear_has_event();
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:HeartRequestC2M.event)
}

// optional int64 defFlowCheckId = 6;
inline bool HeartRequestC2M::has_defflowcheckid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeartRequestC2M::set_has_defflowcheckid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeartRequestC2M::clear_has_defflowcheckid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeartRequestC2M::clear_defflowcheckid() {
  defflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_defflowcheckid();
}
inline ::google::protobuf::int64 HeartRequestC2M::defflowcheckid() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.defFlowCheckId)
  return defflowcheckid_;
}
inline void HeartRequestC2M::set_defflowcheckid(::google::protobuf::int64 value) {
  set_has_defflowcheckid();
  defflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:HeartRequestC2M.defFlowCheckId)
}

// optional int64 groupFlowCheckId = 7;
inline bool HeartRequestC2M::has_groupflowcheckid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeartRequestC2M::set_has_groupflowcheckid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeartRequestC2M::clear_has_groupflowcheckid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeartRequestC2M::clear_groupflowcheckid() {
  groupflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_groupflowcheckid();
}
inline ::google::protobuf::int64 HeartRequestC2M::groupflowcheckid() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.groupFlowCheckId)
  return groupflowcheckid_;
}
inline void HeartRequestC2M::set_groupflowcheckid(::google::protobuf::int64 value) {
  set_has_groupflowcheckid();
  groupflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:HeartRequestC2M.groupFlowCheckId)
}

// optional int64 ssdStoreId = 8;
inline bool HeartRequestC2M::has_ssdstoreid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeartRequestC2M::set_has_ssdstoreid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeartRequestC2M::clear_has_ssdstoreid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeartRequestC2M::clear_ssdstoreid() {
  ssdstoreid_ = GOOGLE_LONGLONG(0);
  clear_has_ssdstoreid();
}
inline ::google::protobuf::int64 HeartRequestC2M::ssdstoreid() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.ssdStoreId)
  return ssdstoreid_;
}
inline void HeartRequestC2M::set_ssdstoreid(::google::protobuf::int64 value) {
  set_has_ssdstoreid();
  ssdstoreid_ = value;
  // @@protoc_insertion_point(field_set:HeartRequestC2M.ssdStoreId)
}

// optional int32 qryPriorityId = 9;
inline bool HeartRequestC2M::has_qrypriorityid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeartRequestC2M::set_has_qrypriorityid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeartRequestC2M::clear_has_qrypriorityid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeartRequestC2M::clear_qrypriorityid() {
  qrypriorityid_ = 0;
  clear_has_qrypriorityid();
}
inline ::google::protobuf::int32 HeartRequestC2M::qrypriorityid() const {
  // @@protoc_insertion_point(field_get:HeartRequestC2M.qryPriorityId)
  return qrypriorityid_;
}
inline void HeartRequestC2M::set_qrypriorityid(::google::protobuf::int32 value) {
  set_has_qrypriorityid();
  qrypriorityid_ = value;
  // @@protoc_insertion_point(field_set:HeartRequestC2M.qryPriorityId)
}

// optional .MasterCertificateInfo authInfo = 10;
inline bool HeartRequestC2M::has_authinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartRequestC2M::set_has_authinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartRequestC2M::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartRequestC2M::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::MasterCertificateInfo& HeartRequestC2M::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::MasterCertificateInfo& HeartRequestC2M::authinfo() const {
  const ::MasterCertificateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:HeartRequestC2M.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterCertificateInfo*>(
      &::_MasterCertificateInfo_default_instance_);
}
inline ::MasterCertificateInfo* HeartRequestC2M::release_authinfo() {
  // @@protoc_insertion_point(field_release:HeartRequestC2M.authInfo)
  clear_has_authinfo();
  ::MasterCertificateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::MasterCertificateInfo* HeartRequestC2M::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterCertificateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HeartRequestC2M.authInfo)
  return authinfo_;
}
inline void HeartRequestC2M::set_allocated_authinfo(::MasterCertificateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:HeartRequestC2M.authInfo)
}

// -------------------------------------------------------------------

// HeartResponseM2C

// required bool success = 1;
inline bool HeartResponseM2C::has_success() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeartResponseM2C::set_has_success() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeartResponseM2C::clear_has_success() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeartResponseM2C::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool HeartResponseM2C::success() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.success)
  return success_;
}
inline void HeartResponseM2C::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.success)
}

// required int32 errCode = 2;
inline bool HeartResponseM2C::has_errcode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeartResponseM2C::set_has_errcode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeartResponseM2C::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeartResponseM2C::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 HeartResponseM2C::errcode() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.errCode)
  return errcode_;
}
inline void HeartResponseM2C::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.errCode)
}

// required string errMsg = 3;
inline bool HeartResponseM2C::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartResponseM2C::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartResponseM2C::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartResponseM2C::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errmsg();
}
inline const ::std::string& HeartResponseM2C::errmsg() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.errMsg)
  return errmsg_.GetNoArena();
}
inline void HeartResponseM2C::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartResponseM2C.errMsg)
}
#if LANG_CXX11
inline void HeartResponseM2C::set_errmsg(::std::string&& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartResponseM2C.errMsg)
}
#endif
inline void HeartResponseM2C::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartResponseM2C.errMsg)
}
inline void HeartResponseM2C::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartResponseM2C.errMsg)
}
inline ::std::string* HeartResponseM2C::mutable_errmsg() {
  set_has_errmsg();
  // @@protoc_insertion_point(field_mutable:HeartResponseM2C.errMsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartResponseM2C::release_errmsg() {
  // @@protoc_insertion_point(field_release:HeartResponseM2C.errMsg)
  if (!has_errmsg()) {
    return NULL;
  }
  clear_has_errmsg();
  return errmsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartResponseM2C::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2C.errMsg)
}

// optional .EventProto event = 4;
inline bool HeartResponseM2C::has_event() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartResponseM2C::set_has_event() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartResponseM2C::clear_has_event() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartResponseM2C::clear_event() {
  if (event_ != NULL) event_->Clear();
  clear_has_event();
}
inline const ::EventProto& HeartResponseM2C::_internal_event() const {
  return *event_;
}
inline const ::EventProto& HeartResponseM2C::event() const {
  const ::EventProto* p = event_;
  // @@protoc_insertion_point(field_get:HeartResponseM2C.event)
  return p != NULL ? *p : *reinterpret_cast<const ::EventProto*>(
      &::_EventProto_default_instance_);
}
inline ::EventProto* HeartResponseM2C::release_event() {
  // @@protoc_insertion_point(field_release:HeartResponseM2C.event)
  clear_has_event();
  ::EventProto* temp = event_;
  event_ = NULL;
  return temp;
}
inline ::EventProto* HeartResponseM2C::mutable_event() {
  set_has_event();
  if (event_ == NULL) {
    auto* p = CreateMaybeMessage<::EventProto>(GetArenaNoVirtual());
    event_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HeartResponseM2C.event)
  return event_;
}
inline void HeartResponseM2C::set_allocated_event(::EventProto* event) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_;
  }
  if (event) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      event = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    set_has_event();
  } else {
    clear_has_event();
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2C.event)
}

// optional bool notAllocated = 5;
inline bool HeartResponseM2C::has_notallocated() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeartResponseM2C::set_has_notallocated() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeartResponseM2C::clear_has_notallocated() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeartResponseM2C::clear_notallocated() {
  notallocated_ = false;
  clear_has_notallocated();
}
inline bool HeartResponseM2C::notallocated() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.notAllocated)
  return notallocated_;
}
inline void HeartResponseM2C::set_notallocated(bool value) {
  set_has_notallocated();
  notallocated_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.notAllocated)
}

// optional int64 defFlowCheckId = 6;
inline bool HeartResponseM2C::has_defflowcheckid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeartResponseM2C::set_has_defflowcheckid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeartResponseM2C::clear_has_defflowcheckid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeartResponseM2C::clear_defflowcheckid() {
  defflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_defflowcheckid();
}
inline ::google::protobuf::int64 HeartResponseM2C::defflowcheckid() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.defFlowCheckId)
  return defflowcheckid_;
}
inline void HeartResponseM2C::set_defflowcheckid(::google::protobuf::int64 value) {
  set_has_defflowcheckid();
  defflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.defFlowCheckId)
}

// optional string defFlowControlInfo = 7;
inline bool HeartResponseM2C::has_defflowcontrolinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartResponseM2C::set_has_defflowcontrolinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartResponseM2C::clear_has_defflowcontrolinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartResponseM2C::clear_defflowcontrolinfo() {
  defflowcontrolinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_defflowcontrolinfo();
}
inline const ::std::string& HeartResponseM2C::defflowcontrolinfo() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.defFlowControlInfo)
  return defflowcontrolinfo_.GetNoArena();
}
inline void HeartResponseM2C::set_defflowcontrolinfo(const ::std::string& value) {
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartResponseM2C.defFlowControlInfo)
}
#if LANG_CXX11
inline void HeartResponseM2C::set_defflowcontrolinfo(::std::string&& value) {
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartResponseM2C.defFlowControlInfo)
}
#endif
inline void HeartResponseM2C::set_defflowcontrolinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartResponseM2C.defFlowControlInfo)
}
inline void HeartResponseM2C::set_defflowcontrolinfo(const char* value, size_t size) {
  set_has_defflowcontrolinfo();
  defflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartResponseM2C.defFlowControlInfo)
}
inline ::std::string* HeartResponseM2C::mutable_defflowcontrolinfo() {
  set_has_defflowcontrolinfo();
  // @@protoc_insertion_point(field_mutable:HeartResponseM2C.defFlowControlInfo)
  return defflowcontrolinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartResponseM2C::release_defflowcontrolinfo() {
  // @@protoc_insertion_point(field_release:HeartResponseM2C.defFlowControlInfo)
  if (!has_defflowcontrolinfo()) {
    return NULL;
  }
  clear_has_defflowcontrolinfo();
  return defflowcontrolinfo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartResponseM2C::set_allocated_defflowcontrolinfo(::std::string* defflowcontrolinfo) {
  if (defflowcontrolinfo != NULL) {
    set_has_defflowcontrolinfo();
  } else {
    clear_has_defflowcontrolinfo();
  }
  defflowcontrolinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), defflowcontrolinfo);
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2C.defFlowControlInfo)
}

// optional int64 groupFlowCheckId = 8;
inline bool HeartResponseM2C::has_groupflowcheckid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeartResponseM2C::set_has_groupflowcheckid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeartResponseM2C::clear_has_groupflowcheckid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeartResponseM2C::clear_groupflowcheckid() {
  groupflowcheckid_ = GOOGLE_LONGLONG(0);
  clear_has_groupflowcheckid();
}
inline ::google::protobuf::int64 HeartResponseM2C::groupflowcheckid() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.groupFlowCheckId)
  return groupflowcheckid_;
}
inline void HeartResponseM2C::set_groupflowcheckid(::google::protobuf::int64 value) {
  set_has_groupflowcheckid();
  groupflowcheckid_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.groupFlowCheckId)
}

// optional string groupFlowControlInfo = 9;
inline bool HeartResponseM2C::has_groupflowcontrolinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartResponseM2C::set_has_groupflowcontrolinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartResponseM2C::clear_has_groupflowcontrolinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartResponseM2C::clear_groupflowcontrolinfo() {
  groupflowcontrolinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupflowcontrolinfo();
}
inline const ::std::string& HeartResponseM2C::groupflowcontrolinfo() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.groupFlowControlInfo)
  return groupflowcontrolinfo_.GetNoArena();
}
inline void HeartResponseM2C::set_groupflowcontrolinfo(const ::std::string& value) {
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HeartResponseM2C.groupFlowControlInfo)
}
#if LANG_CXX11
inline void HeartResponseM2C::set_groupflowcontrolinfo(::std::string&& value) {
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HeartResponseM2C.groupFlowControlInfo)
}
#endif
inline void HeartResponseM2C::set_groupflowcontrolinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HeartResponseM2C.groupFlowControlInfo)
}
inline void HeartResponseM2C::set_groupflowcontrolinfo(const char* value, size_t size) {
  set_has_groupflowcontrolinfo();
  groupflowcontrolinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HeartResponseM2C.groupFlowControlInfo)
}
inline ::std::string* HeartResponseM2C::mutable_groupflowcontrolinfo() {
  set_has_groupflowcontrolinfo();
  // @@protoc_insertion_point(field_mutable:HeartResponseM2C.groupFlowControlInfo)
  return groupflowcontrolinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartResponseM2C::release_groupflowcontrolinfo() {
  // @@protoc_insertion_point(field_release:HeartResponseM2C.groupFlowControlInfo)
  if (!has_groupflowcontrolinfo()) {
    return NULL;
  }
  clear_has_groupflowcontrolinfo();
  return groupflowcontrolinfo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartResponseM2C::set_allocated_groupflowcontrolinfo(::std::string* groupflowcontrolinfo) {
  if (groupflowcontrolinfo != NULL) {
    set_has_groupflowcontrolinfo();
  } else {
    clear_has_groupflowcontrolinfo();
  }
  groupflowcontrolinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupflowcontrolinfo);
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2C.groupFlowControlInfo)
}

// optional int64 ssdStoreId = 10;
inline bool HeartResponseM2C::has_ssdstoreid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HeartResponseM2C::set_has_ssdstoreid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HeartResponseM2C::clear_has_ssdstoreid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HeartResponseM2C::clear_ssdstoreid() {
  ssdstoreid_ = GOOGLE_LONGLONG(0);
  clear_has_ssdstoreid();
}
inline ::google::protobuf::int64 HeartResponseM2C::ssdstoreid() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.ssdStoreId)
  return ssdstoreid_;
}
inline void HeartResponseM2C::set_ssdstoreid(::google::protobuf::int64 value) {
  set_has_ssdstoreid();
  ssdstoreid_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.ssdStoreId)
}

// optional int32 qryPriorityId = 11;
inline bool HeartResponseM2C::has_qrypriorityid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HeartResponseM2C::set_has_qrypriorityid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HeartResponseM2C::clear_has_qrypriorityid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HeartResponseM2C::clear_qrypriorityid() {
  qrypriorityid_ = 0;
  clear_has_qrypriorityid();
}
inline ::google::protobuf::int32 HeartResponseM2C::qrypriorityid() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.qryPriorityId)
  return qrypriorityid_;
}
inline void HeartResponseM2C::set_qrypriorityid(::google::protobuf::int32 value) {
  set_has_qrypriorityid();
  qrypriorityid_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.qryPriorityId)
}

// optional bool requireAuth = 12;
inline bool HeartResponseM2C::has_requireauth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeartResponseM2C::set_has_requireauth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeartResponseM2C::clear_has_requireauth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeartResponseM2C::clear_requireauth() {
  requireauth_ = false;
  clear_has_requireauth();
}
inline bool HeartResponseM2C::requireauth() const {
  // @@protoc_insertion_point(field_get:HeartResponseM2C.requireAuth)
  return requireauth_;
}
inline void HeartResponseM2C::set_requireauth(bool value) {
  set_has_requireauth();
  requireauth_ = value;
  // @@protoc_insertion_point(field_set:HeartResponseM2C.requireAuth)
}

// optional .MasterAuthorizedInfo authorizedInfo = 13;
inline bool HeartResponseM2C::has_authorizedinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeartResponseM2C::set_has_authorizedinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeartResponseM2C::clear_has_authorizedinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeartResponseM2C::clear_authorizedinfo() {
  if (authorizedinfo_ != NULL) authorizedinfo_->Clear();
  clear_has_authorizedinfo();
}
inline const ::MasterAuthorizedInfo& HeartResponseM2C::_internal_authorizedinfo() const {
  return *authorizedinfo_;
}
inline const ::MasterAuthorizedInfo& HeartResponseM2C::authorizedinfo() const {
  const ::MasterAuthorizedInfo* p = authorizedinfo_;
  // @@protoc_insertion_point(field_get:HeartResponseM2C.authorizedInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterAuthorizedInfo*>(
      &::_MasterAuthorizedInfo_default_instance_);
}
inline ::MasterAuthorizedInfo* HeartResponseM2C::release_authorizedinfo() {
  // @@protoc_insertion_point(field_release:HeartResponseM2C.authorizedInfo)
  clear_has_authorizedinfo();
  ::MasterAuthorizedInfo* temp = authorizedinfo_;
  authorizedinfo_ = NULL;
  return temp;
}
inline ::MasterAuthorizedInfo* HeartResponseM2C::mutable_authorizedinfo() {
  set_has_authorizedinfo();
  if (authorizedinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterAuthorizedInfo>(GetArenaNoVirtual());
    authorizedinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:HeartResponseM2C.authorizedInfo)
  return authorizedinfo_;
}
inline void HeartResponseM2C::set_allocated_authorizedinfo(::MasterAuthorizedInfo* authorizedinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authorizedinfo_;
  }
  if (authorizedinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authorizedinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authorizedinfo, submessage_arena);
    }
    set_has_authorizedinfo();
  } else {
    clear_has_authorizedinfo();
  }
  authorizedinfo_ = authorizedinfo;
  // @@protoc_insertion_point(field_set_allocated:HeartResponseM2C.authorizedInfo)
}

// -------------------------------------------------------------------

// CloseRequestC2M

// required string clientId = 1;
inline bool CloseRequestC2M::has_clientid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseRequestC2M::set_has_clientid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseRequestC2M::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseRequestC2M::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& CloseRequestC2M::clientid() const {
  // @@protoc_insertion_point(field_get:CloseRequestC2M.clientId)
  return clientid_.GetNoArena();
}
inline void CloseRequestC2M::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CloseRequestC2M.clientId)
}
#if LANG_CXX11
inline void CloseRequestC2M::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CloseRequestC2M.clientId)
}
#endif
inline void CloseRequestC2M::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CloseRequestC2M.clientId)
}
inline void CloseRequestC2M::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CloseRequestC2M.clientId)
}
inline ::std::string* CloseRequestC2M::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:CloseRequestC2M.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseRequestC2M::release_clientid() {
  // @@protoc_insertion_point(field_release:CloseRequestC2M.clientId)
  if (!has_clientid()) {
    return NULL;
  }
  clear_has_clientid();
  return clientid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseRequestC2M::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:CloseRequestC2M.clientId)
}

// required string groupName = 2;
inline bool CloseRequestC2M::has_groupname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseRequestC2M::set_has_groupname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseRequestC2M::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseRequestC2M::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupname();
}
inline const ::std::string& CloseRequestC2M::groupname() const {
  // @@protoc_insertion_point(field_get:CloseRequestC2M.groupName)
  return groupname_.GetNoArena();
}
inline void CloseRequestC2M::set_groupname(const ::std::string& value) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CloseRequestC2M.groupName)
}
#if LANG_CXX11
inline void CloseRequestC2M::set_groupname(::std::string&& value) {
  set_has_groupname();
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CloseRequestC2M.groupName)
}
#endif
inline void CloseRequestC2M::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CloseRequestC2M.groupName)
}
inline void CloseRequestC2M::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CloseRequestC2M.groupName)
}
inline ::std::string* CloseRequestC2M::mutable_groupname() {
  set_has_groupname();
  // @@protoc_insertion_point(field_mutable:CloseRequestC2M.groupName)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseRequestC2M::release_groupname() {
  // @@protoc_insertion_point(field_release:CloseRequestC2M.groupName)
  if (!has_groupname()) {
    return NULL;
  }
  clear_has_groupname();
  return groupname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseRequestC2M::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    set_has_groupname();
  } else {
    clear_has_groupname();
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:CloseRequestC2M.groupName)
}

// optional .MasterCertificateInfo authInfo = 3;
inline bool CloseRequestC2M::has_authinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CloseRequestC2M::set_has_authinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CloseRequestC2M::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CloseRequestC2M::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->Clear();
  clear_has_authinfo();
}
inline const ::MasterCertificateInfo& CloseRequestC2M::_internal_authinfo() const {
  return *authinfo_;
}
inline const ::MasterCertificateInfo& CloseRequestC2M::authinfo() const {
  const ::MasterCertificateInfo* p = authinfo_;
  // @@protoc_insertion_point(field_get:CloseRequestC2M.authInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::MasterCertificateInfo*>(
      &::_MasterCertificateInfo_default_instance_);
}
inline ::MasterCertificateInfo* CloseRequestC2M::release_authinfo() {
  // @@protoc_insertion_point(field_release:CloseRequestC2M.authInfo)
  clear_has_authinfo();
  ::MasterCertificateInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline ::MasterCertificateInfo* CloseRequestC2M::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) {
    auto* p = CreateMaybeMessage<::MasterCertificateInfo>(GetArenaNoVirtual());
    authinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CloseRequestC2M.authInfo)
  return authinfo_;
}
inline void CloseRequestC2M::set_allocated_authinfo(::MasterCertificateInfo* authinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete authinfo_;
  }
  if (authinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      authinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, authinfo, submessage_arena);
    }
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
  authinfo_ = authinfo;
  // @@protoc_insertion_point(field_set_allocated:CloseRequestC2M.authInfo)
}

// -------------------------------------------------------------------

// CloseResponseM2C

// required bool success = 1;
inline bool CloseResponseM2C::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseResponseM2C::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseResponseM2C::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseResponseM2C::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool CloseResponseM2C::success() const {
  // @@protoc_insertion_point(field_get:CloseResponseM2C.success)
  return success_;
}
inline void CloseResponseM2C::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:CloseResponseM2C.success)
}

// required int32 errCode = 2;
inline bool CloseResponseM2C::has_errcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CloseResponseM2C::set_has_errcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CloseResponseM2C::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CloseResponseM2C::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::google::protobuf::int32 CloseResponseM2C::errcode() const {
  // @@protoc_insertion_point(field_get:CloseResponseM2C.errCode)
  return errcode_;
}
inline void CloseResponseM2C::set_errcode(::google::protobuf::int32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:CloseResponseM2C.errCode)
}

// required string errMsg = 3;
inline bool CloseResponseM2C::has_errmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseResponseM2C::set_has_errmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseResponseM2C::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseResponseM2C::clear_errmsg() {
  errmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errmsg();
}
inline const ::std::string& CloseResponseM2C::errmsg() const {
  // @@protoc_insertion_point(field_get:CloseResponseM2C.errMsg)
  return errmsg_.GetNoArena();
}
inline void CloseResponseM2C::set_errmsg(const ::std::string& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CloseResponseM2C.errMsg)
}
#if LANG_CXX11
inline void CloseResponseM2C::set_errmsg(::std::string&& value) {
  set_has_errmsg();
  errmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CloseResponseM2C.errMsg)
}
#endif
inline void CloseResponseM2C::set_errmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CloseResponseM2C.errMsg)
}
inline void CloseResponseM2C::set_errmsg(const char* value, size_t size) {
  set_has_errmsg();
  errmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CloseResponseM2C.errMsg)
}
inline ::std::string* CloseResponseM2C::mutable_errmsg() {
  set_has_errmsg();
  // @@protoc_insertion_point(field_mutable:CloseResponseM2C.errMsg)
  return errmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseResponseM2C::release_errmsg() {
  // @@protoc_insertion_point(field_release:CloseResponseM2C.errMsg)
  if (!has_errmsg()) {
    return NULL;
  }
  clear_has_errmsg();
  return errmsg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseResponseM2C::set_allocated_errmsg(::std::string* errmsg) {
  if (errmsg != NULL) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
  errmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmsg);
  // @@protoc_insertion_point(field_set_allocated:CloseResponseM2C.errMsg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_MasterService_2eproto
