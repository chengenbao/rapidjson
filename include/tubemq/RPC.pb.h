// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RPC.proto

#ifndef PROTOBUF_INCLUDED_RPC_2eproto
#define PROTOBUF_INCLUDED_RPC_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_RPC_2eproto 

namespace protobuf_RPC_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_RPC_2eproto
class RequestBody;
class RequestBodyDefaultTypeInternal;
extern RequestBodyDefaultTypeInternal _RequestBody_default_instance_;
class RequestHeader;
class RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
class ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class RpcConnHeader;
class RpcConnHeaderDefaultTypeInternal;
extern RpcConnHeaderDefaultTypeInternal _RpcConnHeader_default_instance_;
class RspExceptionBody;
class RspExceptionBodyDefaultTypeInternal;
extern RspExceptionBodyDefaultTypeInternal _RspExceptionBody_default_instance_;
class RspResponseBody;
class RspResponseBodyDefaultTypeInternal;
extern RspResponseBodyDefaultTypeInternal _RspResponseBody_default_instance_;
namespace google {
namespace protobuf {
template<> ::RequestBody* Arena::CreateMaybeMessage<::RequestBody>(Arena*);
template<> ::RequestHeader* Arena::CreateMaybeMessage<::RequestHeader>(Arena*);
template<> ::ResponseHeader* Arena::CreateMaybeMessage<::ResponseHeader>(Arena*);
template<> ::RpcConnHeader* Arena::CreateMaybeMessage<::RpcConnHeader>(Arena*);
template<> ::RspExceptionBody* Arena::CreateMaybeMessage<::RspExceptionBody>(Arena*);
template<> ::RspResponseBody* Arena::CreateMaybeMessage<::RspResponseBody>(Arena*);
}  // namespace protobuf
}  // namespace google

enum ResponseHeader_Status {
  ResponseHeader_Status_SUCCESS = 0,
  ResponseHeader_Status_ERROR = 1,
  ResponseHeader_Status_FATAL = 2
};
bool ResponseHeader_Status_IsValid(int value);
const ResponseHeader_Status ResponseHeader_Status_Status_MIN = ResponseHeader_Status_SUCCESS;
const ResponseHeader_Status ResponseHeader_Status_Status_MAX = ResponseHeader_Status_FATAL;
const int ResponseHeader_Status_Status_ARRAYSIZE = ResponseHeader_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseHeader_Status_descriptor();
inline const ::std::string& ResponseHeader_Status_Name(ResponseHeader_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseHeader_Status_descriptor(), value);
}
inline bool ResponseHeader_Status_Parse(
    const ::std::string& name, ResponseHeader_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseHeader_Status>(
    ResponseHeader_Status_descriptor(), name, value);
}
// ===================================================================

class RpcConnHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RpcConnHeader) */ {
 public:
  RpcConnHeader();
  virtual ~RpcConnHeader();

  RpcConnHeader(const RpcConnHeader& from);

  inline RpcConnHeader& operator=(const RpcConnHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RpcConnHeader(RpcConnHeader&& from) noexcept
    : RpcConnHeader() {
    *this = ::std::move(from);
  }

  inline RpcConnHeader& operator=(RpcConnHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcConnHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RpcConnHeader* internal_default_instance() {
    return reinterpret_cast<const RpcConnHeader*>(
               &_RpcConnHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RpcConnHeader* other);
  friend void swap(RpcConnHeader& a, RpcConnHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RpcConnHeader* New() const final {
    return CreateMaybeMessage<RpcConnHeader>(NULL);
  }

  RpcConnHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RpcConnHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RpcConnHeader& from);
  void MergeFrom(const RpcConnHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcConnHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 traceId = 2;
  bool has_traceid() const;
  void clear_traceid();
  static const int kTraceIdFieldNumber = 2;
  ::google::protobuf::int64 traceid() const;
  void set_traceid(::google::protobuf::int64 value);

  // optional int64 spanId = 3;
  bool has_spanid() const;
  void clear_spanid();
  static const int kSpanIdFieldNumber = 3;
  ::google::protobuf::int64 spanid() const;
  void set_spanid(::google::protobuf::int64 value);

  // optional int64 parentId = 4;
  bool has_parentid() const;
  void clear_parentid();
  static const int kParentIdFieldNumber = 4;
  ::google::protobuf::int64 parentid() const;
  void set_parentid(::google::protobuf::int64 value);

  // required int32 flag = 1;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 1;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RpcConnHeader)
 private:
  void set_has_flag();
  void clear_has_flag();
  void set_has_traceid();
  void clear_has_traceid();
  void set_has_spanid();
  void clear_has_spanid();
  void set_has_parentid();
  void clear_has_parentid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 traceid_;
  ::google::protobuf::int64 spanid_;
  ::google::protobuf::int64 parentid_;
  ::google::protobuf::int32 flag_;
  friend struct ::protobuf_RPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestHeader) */ {
 public:
  RequestHeader();
  virtual ~RequestHeader();

  RequestHeader(const RequestHeader& from);

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RequestHeader* other);
  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestHeader* New() const final {
    return CreateMaybeMessage<RequestHeader>(NULL);
  }

  RequestHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 serviceType = 1;
  bool has_servicetype() const;
  void clear_servicetype();
  static const int kServiceTypeFieldNumber = 1;
  ::google::protobuf::int32 servicetype() const;
  void set_servicetype(::google::protobuf::int32 value);

  // optional int32 protocolVer = 2;
  bool has_protocolver() const;
  void clear_protocolver();
  static const int kProtocolVerFieldNumber = 2;
  ::google::protobuf::int32 protocolver() const;
  void set_protocolver(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RequestHeader)
 private:
  void set_has_servicetype();
  void clear_has_servicetype();
  void set_has_protocolver();
  void clear_has_protocolver();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 servicetype_;
  ::google::protobuf::int32 protocolver_;
  friend struct ::protobuf_RPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestBody) */ {
 public:
  RequestBody();
  virtual ~RequestBody();

  RequestBody(const RequestBody& from);

  inline RequestBody& operator=(const RequestBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestBody(RequestBody&& from) noexcept
    : RequestBody() {
    *this = ::std::move(from);
  }

  inline RequestBody& operator=(RequestBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestBody* internal_default_instance() {
    return reinterpret_cast<const RequestBody*>(
               &_RequestBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RequestBody* other);
  friend void swap(RequestBody& a, RequestBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestBody* New() const final {
    return CreateMaybeMessage<RequestBody>(NULL);
  }

  RequestBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestBody& from);
  void MergeFrom(const RequestBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes request = 3;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 3;
  const ::std::string& request() const;
  void set_request(const ::std::string& value);
  #if LANG_CXX11
  void set_request(::std::string&& value);
  #endif
  void set_request(const char* value);
  void set_request(const void* value, size_t size);
  ::std::string* mutable_request();
  ::std::string* release_request();
  void set_allocated_request(::std::string* request);

  // optional int64 timeout = 2;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  ::google::protobuf::int64 timeout() const;
  void set_timeout(::google::protobuf::int64 value);

  // required int32 method = 1;
  bool has_method() const;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  ::google::protobuf::int32 method() const;
  void set_method(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RequestBody)
 private:
  void set_has_method();
  void clear_has_method();
  void set_has_timeout();
  void clear_has_timeout();
  void set_has_request();
  void clear_has_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr request_;
  ::google::protobuf::int64 timeout_;
  ::google::protobuf::int32 method_;
  friend struct ::protobuf_RPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResponseHeader) */ {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResponseHeader* other);
  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const final {
    return CreateMaybeMessage<ResponseHeader>(NULL);
  }

  ResponseHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseHeader_Status Status;
  static const Status SUCCESS =
    ResponseHeader_Status_SUCCESS;
  static const Status ERROR =
    ResponseHeader_Status_ERROR;
  static const Status FATAL =
    ResponseHeader_Status_FATAL;
  static inline bool Status_IsValid(int value) {
    return ResponseHeader_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ResponseHeader_Status_Status_MIN;
  static const Status Status_MAX =
    ResponseHeader_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ResponseHeader_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ResponseHeader_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ResponseHeader_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ResponseHeader_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ResponseHeader.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::ResponseHeader_Status status() const;
  void set_status(::ResponseHeader_Status value);

  // optional int32 serviceType = 2;
  bool has_servicetype() const;
  void clear_servicetype();
  static const int kServiceTypeFieldNumber = 2;
  ::google::protobuf::int32 servicetype() const;
  void set_servicetype(::google::protobuf::int32 value);

  // optional int32 protocolVer = 3;
  bool has_protocolver() const;
  void clear_protocolver();
  static const int kProtocolVerFieldNumber = 3;
  ::google::protobuf::int32 protocolver() const;
  void set_protocolver(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ResponseHeader)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_servicetype();
  void clear_has_servicetype();
  void set_has_protocolver();
  void clear_has_protocolver();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  ::google::protobuf::int32 servicetype_;
  ::google::protobuf::int32 protocolver_;
  friend struct ::protobuf_RPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RspExceptionBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RspExceptionBody) */ {
 public:
  RspExceptionBody();
  virtual ~RspExceptionBody();

  RspExceptionBody(const RspExceptionBody& from);

  inline RspExceptionBody& operator=(const RspExceptionBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RspExceptionBody(RspExceptionBody&& from) noexcept
    : RspExceptionBody() {
    *this = ::std::move(from);
  }

  inline RspExceptionBody& operator=(RspExceptionBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspExceptionBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RspExceptionBody* internal_default_instance() {
    return reinterpret_cast<const RspExceptionBody*>(
               &_RspExceptionBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RspExceptionBody* other);
  friend void swap(RspExceptionBody& a, RspExceptionBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RspExceptionBody* New() const final {
    return CreateMaybeMessage<RspExceptionBody>(NULL);
  }

  RspExceptionBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RspExceptionBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RspExceptionBody& from);
  void MergeFrom(const RspExceptionBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RspExceptionBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string exceptionName = 1;
  bool has_exceptionname() const;
  void clear_exceptionname();
  static const int kExceptionNameFieldNumber = 1;
  const ::std::string& exceptionname() const;
  void set_exceptionname(const ::std::string& value);
  #if LANG_CXX11
  void set_exceptionname(::std::string&& value);
  #endif
  void set_exceptionname(const char* value);
  void set_exceptionname(const char* value, size_t size);
  ::std::string* mutable_exceptionname();
  ::std::string* release_exceptionname();
  void set_allocated_exceptionname(::std::string* exceptionname);

  // optional string stackTrace = 2;
  bool has_stacktrace() const;
  void clear_stacktrace();
  static const int kStackTraceFieldNumber = 2;
  const ::std::string& stacktrace() const;
  void set_stacktrace(const ::std::string& value);
  #if LANG_CXX11
  void set_stacktrace(::std::string&& value);
  #endif
  void set_stacktrace(const char* value);
  void set_stacktrace(const char* value, size_t size);
  ::std::string* mutable_stacktrace();
  ::std::string* release_stacktrace();
  void set_allocated_stacktrace(::std::string* stacktrace);

  // @@protoc_insertion_point(class_scope:RspExceptionBody)
 private:
  void set_has_exceptionname();
  void clear_has_exceptionname();
  void set_has_stacktrace();
  void clear_has_stacktrace();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr exceptionname_;
  ::google::protobuf::internal::ArenaStringPtr stacktrace_;
  friend struct ::protobuf_RPC_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RspResponseBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RspResponseBody) */ {
 public:
  RspResponseBody();
  virtual ~RspResponseBody();

  RspResponseBody(const RspResponseBody& from);

  inline RspResponseBody& operator=(const RspResponseBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RspResponseBody(RspResponseBody&& from) noexcept
    : RspResponseBody() {
    *this = ::std::move(from);
  }

  inline RspResponseBody& operator=(RspResponseBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspResponseBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RspResponseBody* internal_default_instance() {
    return reinterpret_cast<const RspResponseBody*>(
               &_RspResponseBody_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RspResponseBody* other);
  friend void swap(RspResponseBody& a, RspResponseBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RspResponseBody* New() const final {
    return CreateMaybeMessage<RspResponseBody>(NULL);
  }

  RspResponseBody* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RspResponseBody>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RspResponseBody& from);
  void MergeFrom(const RspResponseBody& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RspResponseBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required int32 method = 1;
  bool has_method() const;
  void clear_method();
  static const int kMethodFieldNumber = 1;
  ::google::protobuf::int32 method() const;
  void set_method(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RspResponseBody)
 private:
  void set_has_method();
  void clear_has_method();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 method_;
  friend struct ::protobuf_RPC_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RpcConnHeader

// required int32 flag = 1;
inline bool RpcConnHeader::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcConnHeader::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcConnHeader::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcConnHeader::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 RpcConnHeader::flag() const {
  // @@protoc_insertion_point(field_get:RpcConnHeader.flag)
  return flag_;
}
inline void RpcConnHeader::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:RpcConnHeader.flag)
}

// optional int64 traceId = 2;
inline bool RpcConnHeader::has_traceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcConnHeader::set_has_traceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcConnHeader::clear_has_traceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcConnHeader::clear_traceid() {
  traceid_ = GOOGLE_LONGLONG(0);
  clear_has_traceid();
}
inline ::google::protobuf::int64 RpcConnHeader::traceid() const {
  // @@protoc_insertion_point(field_get:RpcConnHeader.traceId)
  return traceid_;
}
inline void RpcConnHeader::set_traceid(::google::protobuf::int64 value) {
  set_has_traceid();
  traceid_ = value;
  // @@protoc_insertion_point(field_set:RpcConnHeader.traceId)
}

// optional int64 spanId = 3;
inline bool RpcConnHeader::has_spanid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcConnHeader::set_has_spanid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcConnHeader::clear_has_spanid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcConnHeader::clear_spanid() {
  spanid_ = GOOGLE_LONGLONG(0);
  clear_has_spanid();
}
inline ::google::protobuf::int64 RpcConnHeader::spanid() const {
  // @@protoc_insertion_point(field_get:RpcConnHeader.spanId)
  return spanid_;
}
inline void RpcConnHeader::set_spanid(::google::protobuf::int64 value) {
  set_has_spanid();
  spanid_ = value;
  // @@protoc_insertion_point(field_set:RpcConnHeader.spanId)
}

// optional int64 parentId = 4;
inline bool RpcConnHeader::has_parentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcConnHeader::set_has_parentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcConnHeader::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcConnHeader::clear_parentid() {
  parentid_ = GOOGLE_LONGLONG(0);
  clear_has_parentid();
}
inline ::google::protobuf::int64 RpcConnHeader::parentid() const {
  // @@protoc_insertion_point(field_get:RpcConnHeader.parentId)
  return parentid_;
}
inline void RpcConnHeader::set_parentid(::google::protobuf::int64 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:RpcConnHeader.parentId)
}

// -------------------------------------------------------------------

// RequestHeader

// optional int32 serviceType = 1;
inline bool RequestHeader::has_servicetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHeader::set_has_servicetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHeader::clear_has_servicetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHeader::clear_servicetype() {
  servicetype_ = 0;
  clear_has_servicetype();
}
inline ::google::protobuf::int32 RequestHeader::servicetype() const {
  // @@protoc_insertion_point(field_get:RequestHeader.serviceType)
  return servicetype_;
}
inline void RequestHeader::set_servicetype(::google::protobuf::int32 value) {
  set_has_servicetype();
  servicetype_ = value;
  // @@protoc_insertion_point(field_set:RequestHeader.serviceType)
}

// optional int32 protocolVer = 2;
inline bool RequestHeader::has_protocolver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHeader::set_has_protocolver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHeader::clear_has_protocolver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHeader::clear_protocolver() {
  protocolver_ = 0;
  clear_has_protocolver();
}
inline ::google::protobuf::int32 RequestHeader::protocolver() const {
  // @@protoc_insertion_point(field_get:RequestHeader.protocolVer)
  return protocolver_;
}
inline void RequestHeader::set_protocolver(::google::protobuf::int32 value) {
  set_has_protocolver();
  protocolver_ = value;
  // @@protoc_insertion_point(field_set:RequestHeader.protocolVer)
}

// -------------------------------------------------------------------

// RequestBody

// required int32 method = 1;
inline bool RequestBody::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBody::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBody::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBody::clear_method() {
  method_ = 0;
  clear_has_method();
}
inline ::google::protobuf::int32 RequestBody::method() const {
  // @@protoc_insertion_point(field_get:RequestBody.method)
  return method_;
}
inline void RequestBody::set_method(::google::protobuf::int32 value) {
  set_has_method();
  method_ = value;
  // @@protoc_insertion_point(field_set:RequestBody.method)
}

// optional int64 timeout = 2;
inline bool RequestBody::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBody::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBody::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBody::clear_timeout() {
  timeout_ = GOOGLE_LONGLONG(0);
  clear_has_timeout();
}
inline ::google::protobuf::int64 RequestBody::timeout() const {
  // @@protoc_insertion_point(field_get:RequestBody.timeout)
  return timeout_;
}
inline void RequestBody::set_timeout(::google::protobuf::int64 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:RequestBody.timeout)
}

// optional bytes request = 3;
inline bool RequestBody::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBody::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBody::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBody::clear_request() {
  request_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request();
}
inline const ::std::string& RequestBody::request() const {
  // @@protoc_insertion_point(field_get:RequestBody.request)
  return request_.GetNoArena();
}
inline void RequestBody::set_request(const ::std::string& value) {
  set_has_request();
  request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestBody.request)
}
#if LANG_CXX11
inline void RequestBody::set_request(::std::string&& value) {
  set_has_request();
  request_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RequestBody.request)
}
#endif
inline void RequestBody::set_request(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_request();
  request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestBody.request)
}
inline void RequestBody::set_request(const void* value, size_t size) {
  set_has_request();
  request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestBody.request)
}
inline ::std::string* RequestBody::mutable_request() {
  set_has_request();
  // @@protoc_insertion_point(field_mutable:RequestBody.request)
  return request_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestBody::release_request() {
  // @@protoc_insertion_point(field_release:RequestBody.request)
  if (!has_request()) {
    return NULL;
  }
  clear_has_request();
  return request_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestBody::set_allocated_request(::std::string* request) {
  if (request != NULL) {
    set_has_request();
  } else {
    clear_has_request();
  }
  request_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request);
  // @@protoc_insertion_point(field_set_allocated:RequestBody.request)
}

// -------------------------------------------------------------------

// ResponseHeader

// required .ResponseHeader.Status status = 1;
inline bool ResponseHeader::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHeader::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHeader::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHeader::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::ResponseHeader_Status ResponseHeader::status() const {
  // @@protoc_insertion_point(field_get:ResponseHeader.status)
  return static_cast< ::ResponseHeader_Status >(status_);
}
inline void ResponseHeader::set_status(::ResponseHeader_Status value) {
  assert(::ResponseHeader_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ResponseHeader.status)
}

// optional int32 serviceType = 2;
inline bool ResponseHeader::has_servicetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseHeader::set_has_servicetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseHeader::clear_has_servicetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseHeader::clear_servicetype() {
  servicetype_ = 0;
  clear_has_servicetype();
}
inline ::google::protobuf::int32 ResponseHeader::servicetype() const {
  // @@protoc_insertion_point(field_get:ResponseHeader.serviceType)
  return servicetype_;
}
inline void ResponseHeader::set_servicetype(::google::protobuf::int32 value) {
  set_has_servicetype();
  servicetype_ = value;
  // @@protoc_insertion_point(field_set:ResponseHeader.serviceType)
}

// optional int32 protocolVer = 3;
inline bool ResponseHeader::has_protocolver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseHeader::set_has_protocolver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseHeader::clear_has_protocolver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseHeader::clear_protocolver() {
  protocolver_ = 0;
  clear_has_protocolver();
}
inline ::google::protobuf::int32 ResponseHeader::protocolver() const {
  // @@protoc_insertion_point(field_get:ResponseHeader.protocolVer)
  return protocolver_;
}
inline void ResponseHeader::set_protocolver(::google::protobuf::int32 value) {
  set_has_protocolver();
  protocolver_ = value;
  // @@protoc_insertion_point(field_set:ResponseHeader.protocolVer)
}

// -------------------------------------------------------------------

// RspExceptionBody

// required string exceptionName = 1;
inline bool RspExceptionBody::has_exceptionname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspExceptionBody::set_has_exceptionname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspExceptionBody::clear_has_exceptionname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspExceptionBody::clear_exceptionname() {
  exceptionname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exceptionname();
}
inline const ::std::string& RspExceptionBody::exceptionname() const {
  // @@protoc_insertion_point(field_get:RspExceptionBody.exceptionName)
  return exceptionname_.GetNoArena();
}
inline void RspExceptionBody::set_exceptionname(const ::std::string& value) {
  set_has_exceptionname();
  exceptionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RspExceptionBody.exceptionName)
}
#if LANG_CXX11
inline void RspExceptionBody::set_exceptionname(::std::string&& value) {
  set_has_exceptionname();
  exceptionname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RspExceptionBody.exceptionName)
}
#endif
inline void RspExceptionBody::set_exceptionname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_exceptionname();
  exceptionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RspExceptionBody.exceptionName)
}
inline void RspExceptionBody::set_exceptionname(const char* value, size_t size) {
  set_has_exceptionname();
  exceptionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RspExceptionBody.exceptionName)
}
inline ::std::string* RspExceptionBody::mutable_exceptionname() {
  set_has_exceptionname();
  // @@protoc_insertion_point(field_mutable:RspExceptionBody.exceptionName)
  return exceptionname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RspExceptionBody::release_exceptionname() {
  // @@protoc_insertion_point(field_release:RspExceptionBody.exceptionName)
  if (!has_exceptionname()) {
    return NULL;
  }
  clear_has_exceptionname();
  return exceptionname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RspExceptionBody::set_allocated_exceptionname(::std::string* exceptionname) {
  if (exceptionname != NULL) {
    set_has_exceptionname();
  } else {
    clear_has_exceptionname();
  }
  exceptionname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exceptionname);
  // @@protoc_insertion_point(field_set_allocated:RspExceptionBody.exceptionName)
}

// optional string stackTrace = 2;
inline bool RspExceptionBody::has_stacktrace() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspExceptionBody::set_has_stacktrace() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspExceptionBody::clear_has_stacktrace() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspExceptionBody::clear_stacktrace() {
  stacktrace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stacktrace();
}
inline const ::std::string& RspExceptionBody::stacktrace() const {
  // @@protoc_insertion_point(field_get:RspExceptionBody.stackTrace)
  return stacktrace_.GetNoArena();
}
inline void RspExceptionBody::set_stacktrace(const ::std::string& value) {
  set_has_stacktrace();
  stacktrace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RspExceptionBody.stackTrace)
}
#if LANG_CXX11
inline void RspExceptionBody::set_stacktrace(::std::string&& value) {
  set_has_stacktrace();
  stacktrace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RspExceptionBody.stackTrace)
}
#endif
inline void RspExceptionBody::set_stacktrace(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_stacktrace();
  stacktrace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RspExceptionBody.stackTrace)
}
inline void RspExceptionBody::set_stacktrace(const char* value, size_t size) {
  set_has_stacktrace();
  stacktrace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RspExceptionBody.stackTrace)
}
inline ::std::string* RspExceptionBody::mutable_stacktrace() {
  set_has_stacktrace();
  // @@protoc_insertion_point(field_mutable:RspExceptionBody.stackTrace)
  return stacktrace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RspExceptionBody::release_stacktrace() {
  // @@protoc_insertion_point(field_release:RspExceptionBody.stackTrace)
  if (!has_stacktrace()) {
    return NULL;
  }
  clear_has_stacktrace();
  return stacktrace_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RspExceptionBody::set_allocated_stacktrace(::std::string* stacktrace) {
  if (stacktrace != NULL) {
    set_has_stacktrace();
  } else {
    clear_has_stacktrace();
  }
  stacktrace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stacktrace);
  // @@protoc_insertion_point(field_set_allocated:RspExceptionBody.stackTrace)
}

// -------------------------------------------------------------------

// RspResponseBody

// required int32 method = 1;
inline bool RspResponseBody::has_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspResponseBody::set_has_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspResponseBody::clear_has_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspResponseBody::clear_method() {
  method_ = 0;
  clear_has_method();
}
inline ::google::protobuf::int32 RspResponseBody::method() const {
  // @@protoc_insertion_point(field_get:RspResponseBody.method)
  return method_;
}
inline void RspResponseBody::set_method(::google::protobuf::int32 value) {
  set_has_method();
  method_ = value;
  // @@protoc_insertion_point(field_set:RspResponseBody.method)
}

// required bytes data = 2;
inline bool RspResponseBody::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspResponseBody::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspResponseBody::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspResponseBody::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& RspResponseBody::data() const {
  // @@protoc_insertion_point(field_get:RspResponseBody.data)
  return data_.GetNoArena();
}
inline void RspResponseBody::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RspResponseBody.data)
}
#if LANG_CXX11
inline void RspResponseBody::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RspResponseBody.data)
}
#endif
inline void RspResponseBody::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RspResponseBody.data)
}
inline void RspResponseBody::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RspResponseBody.data)
}
inline ::std::string* RspResponseBody::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:RspResponseBody.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RspResponseBody::release_data() {
  // @@protoc_insertion_point(field_release:RspResponseBody.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RspResponseBody::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:RspResponseBody.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ResponseHeader_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ResponseHeader_Status>() {
  return ::ResponseHeader_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_RPC_2eproto
